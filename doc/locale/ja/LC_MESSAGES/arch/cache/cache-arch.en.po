# 
msgid ""
msgstr ""
"Project-Id-Version: Apache Traffic Server 4.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-11-08 17:57+0900\n"
"PO-Revision-Date: 2013-11-12 01:50+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../arch/cache/cache-arch.en.rst:19
msgid "Cache Architecture"
msgstr "キャッシュアーキテクチャ"

#: ../../arch/cache/cache-arch.en.rst:24
msgid "Introduction"
msgstr "導入"

#: ../../arch/cache/cache-arch.en.rst:26
msgid ""
"In addition to an HTTP proxy, |ATS| is also an HTTP cache. |TS| can cache "
"any octet stream although it currently supports only those octet streams "
"delivered by the HTTP protocol. When such a stream is cached (along with the"
" HTTP protocol headers) it is termed an *object* in the cache. Each object "
"is identified by a globally unique value called a *cache key*. By default "
"this is generated by taking the `MD5 hash "
"<http://www.openssl.org/docs/crypto/md5.html>`_ of the URI used to retrieve "
"the content from the origin server."
msgstr ""
"HTTP プロキシに加え、 |ATS| は HTTP キャッシュでもあります。 "
"|TS| は、現在サポートしている HTTP プロキシによって配信されるオクテット"
"ストリームのみなら、任意のオクテットストリームをキャッシュできます。"
"そのようなストリームがキャッシュされる時、それは キャッシュ内で"
" *オブジェクト* と呼ばれます。"
"各オブジェクトは *キャッシュキー* と呼ばれる、大域的に一意な値により"
"識別されます。デフォルトではこの値は、オリジンサーバからコンテンツを取得する"
"するために使われる URI の `MD5 ハッシュ "
"<http://www.openssl.org/docs/crypto/md5.html>`_ をとることで生成されます。"

#: ../../arch/cache/cache-arch.en.rst:32
msgid ""
"The purpose of this document is to describe the basic structure and "
"implementation details of the |TS| cache. Configuration of the cache will be"
" discussed only to the extent needed to understand the internal mechanisms. "
"This document will be useful primarily to |TS| developers working on the "
"|TS| codebase or plugins for |TS|. It is assumed the reader is already "
"familiar with the :ref:`admin-guide` and specifically with :ref:`http-proxy-"
"caching` and :ref:`configuring-the-cache` along with the associated "
"configuration files and values."
msgstr ""
"このドキュメントの目的は、 |TS| キャッシュの基本構造と実装の詳細について"
"記述することです。"
"キャッシュの設定については、内部の仕組みを理解するのに必要な範囲でのみ"
"述べられます。このドキュメントは、主に |TS| のコードベースや |TS| の"
"プラグインで働く |TS| デベロッパーにとって有用となるでしょう。"
"読者は、 :ref:`admin-guide` と、特に :ref:`http-proxy-caching` と "
":ref:`configuring-the-cache` 、加えて設定ファイルや設定値に関することに"
"既に詳しいことが想定されます。"

#: ../../arch/cache/cache-arch.en.rst:38
msgid ""
"Unfortunately the internal terminology is not particularly consistent so "
"this document will frequently use terms in different ways than they are used"
" in the code in an attempt to create some consistency."
msgstr ""
"不幸なことに、内部用語は特に一貫していません。"
"従って、このドキュメントは一貫性を得るため、コード内で使われるそれらとは"
"違う表現で頻繁に用語を使用するでしょう。"

#: ../../arch/cache/cache-arch.en.rst:42
msgid "Cache Layout"
msgstr "キャッシュレイアウト"

#: ../../arch/cache/cache-arch.en.rst:44
msgid ""
"The first step in understanding cache operations is to understand the data "
"structures and layout of the cache."
msgstr ""
"キャッシュオペレーションを理解する最初のステップは、データ構造とキャッシュの"
"レイアウトを理解する事です。"

#: ../../arch/cache/cache-arch.en.rst:47
msgid "Cache storage"
msgstr "キャッシュストレージ"

#: ../../arch/cache/cache-arch.en.rst:49
msgid ""
"The raw storage for the |TS| cache is configured in :file:`storage.config`. "
"Each line in the file defines a :term:`cache span` which is treated as an "
"undifferentiated unit of storage."
msgstr ""
"|TS| キャッシュの生のストレージは、 :file:`storage.config` に設定されます。"
"ファイルの各行は、未分化なストレージのユニットとして扱われる :term:`キャッシュ "
"スパン` を定義します。"

#: ../../arch/cache/cache-arch.en.rst:54
msgid "Two cache spans"
msgstr "二つのキャッシュスパン"

#: ../../arch/cache/cache-arch.en.rst:56
msgid ""
"This storage organized in to a set of :term:`cache volume`\\ s which are "
"defined in :file:`volume.config`. Cache volumes can be defined by a "
"percentage of the total storage or an absolute amount of storage. By default"
" each cache volume is spread across all of the cache spans for robustness. "
"The intersection of a cache volume and a cache span is a :term:`cache "
"stripe`. Each cache span is divided in to cache stripes and each cache "
"volume is a collection of those stripes."
msgstr ""
"このストレージは、 :file:`volume.config` 内で定義される :term:`キャッシュ "
"ボリューム` のセットに組織されます。"
"キャッシュボリュームは、ストレージの合計、またはストレージの絶対量の"
"パーセンテージで定義できます。"
"デフォルトでは、各キャッシュボリュームは堅牢性のためにキャッシュスパンの全てに"
"広げられます。"
"キャッシュボリュームとキャッシュスパンの接点は、"
":term:`キャッシュストライプ` です。"
"各キャッシュスパンは、キャッシュストライプに分割されます。各キャッシュ"
"ボリュームは、それらのストライプのコレクションです。"

#: ../../arch/cache/cache-arch.en.rst:59
msgid "If the cache volumes for the example cache spans were defined as"
msgstr ""
"もし、例のキャッシュスパンのキャッシュボリュームが以下のように定義されていたら"

#: ../../arch/cache/cache-arch.en.rst:64
msgid "then the actual layout would look like"
msgstr ""
"その時実際のレイアウトはこのように見えるでしょう。"

#: ../../arch/cache/cache-arch.en.rst:69
msgid ""
"A cached object is stored entirely in a single stripe, and therefore in a "
"single cache span - objects are never split across cache volumes. Objects "
"are assigned to a stripe (and hence to a cache volume) automatically based "
"on a hash of the URI used to retrieve the object from the origin server. It "
"is possible to configure this to a limited extent in :file:`hosting.config` "
"which supports content from specific host or domain to be stored on specific"
" volumes. In addition, as of version 4.0.1 it is possible to control which "
"cache spans (and hence, which cache stripes) are contained in a specific "
"cache volume."
msgstr ""
"キャッシュオブジェクトは、一つのストライプに全体が保存されます。"
"従って一つのキャッシュスパン - オブジェクトは、キャッシュボリュームを横断して"
"分離されることはありません。"
"オブジェクトは、オリジンサーバからオブジェクトを取得するのに使用される "
"URI のハッシュ値に基づき、自動的にストライプ(つまりはキャッシュボリュームにも)"
"に割り当てられます。"
"特定のホストやドメインからのサポートされるコンテンツ を、"
"特定ボリュームに保存することは、 :file:`hosting.config` で、"
"限定的な範囲で設定することが可能です。"
"加えて、バージョン 4.0.1 では、キャッシュスパン(つまりはキャッシュストライプも)"
"が特定のキャッシュボリュームに含まれるよう制御することが可能です。"

#: ../../arch/cache/cache-arch.en.rst:76
msgid ""
"The layout and structure of the cache spans, the cache volumes, and the "
"cache stripes that compose them are derived entirely from the "
":file:`storage.config` and :file:`cache.config` and is recomputed from "
"scratch when the :process:`traffic_server` is started. Therefore any change "
"to those files can (and almost always will) invalidate the existing cache in"
" its entirety."
msgstr ""
"キャッシュスパン、キャッシュボリューム、そしてそれらを構成するキャッシュ"
"ストライプのレイアウトと構造は、全て :file:`storage.config` と"
":file:`cache.config` から取得され、 :process:`traffic_server` が開始された時に"
"最初から再計算されます。"
"従って、それらのファイルへの任意の変更は、(ほとんど常に)それらの全ての"
"既存のキャッシュを無効にできます。"

#: ../../arch/cache/cache-arch.en.rst:82
msgid "Stripe Structure"
msgstr "ストライプ構造"

#: ../../arch/cache/cache-arch.en.rst:84
msgid ""
"|TS| treats the storage associated with a cache stripe as an "
"undifferentiated span of bytes. Internally each stripe is treated almost "
"entirely independently. The data structures described in this section are "
"duplicated for each stripe. Internally the term \"volume\" is used for these"
" stripes and implemented primarily in :cpp:class:`Vol`. What a user thinks "
"of as a volume (what this document calls a \"cache volume\") is represented "
"by :cpp:class:`CacheVol`."
msgstr ""
"キャッシュストライプは区別されないバイト列の範囲として扱われます。"
"内部的に、各ストライプは、ほとんど全体を独立して扱われます。"
"このセクションで記述されるデータ構造は、各ストライプに重複されています。"
"内部的に \"ボリューム\" という単語は、これらのストライプに仕様され、主に"
":cpp:class:`Vol` で実装されています。"
"キャッシュのボリューム(このドキュメントでは\"キャッシュボリューム\")としての"
"ユーザの考えは、 :cpp:class:`CacheVol` で表現されます。"

#: ../../arch/cache/cache-arch.en.rst:91
msgid ""
"Stripe assignment must be done before working with an object because the "
"directory is local to the stripe. Any cached objects for which the stripe "
"assignment is changed are effectively lost as their directory data will not "
"be found in the new stripe."
msgstr ""
"ディレクトリはストライプに配置されるため、ストライプ割当はオブジェクトを"
"扱う動作をする前に行われなければなりません。"
"変更されたストライプ割当のための任意のキャッシュオブジェクトは、これらの新しい"
"ストライプで発見されるはずがないディレクトリデータとして効率的に減らされます。"
"ストライプ割当が、これらのディレクトリデータとして効率的に減らすに変更される。"

#: ../../arch/cache/cache-arch.en.rst:99
msgid "Cache Directory"
msgstr "キャッシュディレクトリ"

#: ../../arch/cache/cache-arch.en.rst:107
msgid ""
"Content in a stripe is tracked via a directory. We call each element of the "
"directory a \"directory entry\" and each is represented by :cpp:class:`Dir`."
" Each entry refers to a chunk of contiguous storage in the cache. These are "
"referred to variously as \"fragments\", \"segments\", \"docs\" / "
"\"documents\", and a few other things. This document will use the term "
"\"fragment\" as that is the most common reference in the code. The term "
"\"Doc\" (for :cpp:class:`Doc`) will be used to refer to the header data for "
"a fragment. Overall the directory is treated as a hash with a \"cache ID\" "
"as the key. A cache ID is a 128 bit (16 byte) value generated in various "
"ways depending on context. This ID is reduced and used as an index in to the"
" directory to locate an entry in the standard way."
msgstr ""
"ストライプのコンテントはディレクトリによって追跡されます。"
"我々はディレクトリの各要素を \"ディレクトリエントリ\" と呼び、それらは "
":cpp:class:`Dir` によって表現されます。"
"各エントリは、キャッシュ内の連続したストレージのチャンクを参照します。"
"これらは \"フラグメント\" や \"セグメント\"、\"ドック\" / \"ドキュメント\" 、その他の"
"幾つかのような 様々なものを参照します。"
"このドキュメントは、\"フラグメント\" という単語を、コード中で最も共通の参照として"
"いるものとして使います。"
"\"Doc\" ( :cpp:class:`Doc` の) という単語は、フラグメントの為のヘッダデータを"
"参照するのに使用されるでしょう。"
"全体的にディレクトリは、キーとして \"キャッシュID\" を伴うハッシュとして扱われます。"
"キャッシュIDは、コンテキストに依存した幾つかの方法で生成された128ビット"
"(16バイト)の値です。"
"このキーは減らされ、ディレクトリでエントリを配置するための標準的な方法の"
"インデックスとして使用されます。"

#: ../../arch/cache/cache-arch.en.rst:115
msgid ""
"The directory is used as a memory resident structure which means a directory"
" entry is as small as possible (currently 10 bytes). This forces some "
"compromises on the data that can be stored there. On the other hand this "
"means that most cache misses do not require disk I/O which has a large "
"performance benefit."
msgstr ""
"ディレクトリはメモリ常住の構造として使用されます。"
"これはディレクトリエントリは可能な限り小さい（現在、10バイト）ことを意味します。"
"これは、そこに保存できるデータに幾つかの譲歩を強要します。"
"一方でこれは、ほとんどのキャッシュミスはディスクI/Oを要求しない、大きな性能面の"
"恩恵を持つことを意味します。"

#: ../../arch/cache/cache-arch.en.rst:119
msgid ""
"An additional point is the directory is always fully sized. Once a stripe is"
" initialized the directory size is fixed and never changed. This size is "
"related (roughly linearly) to the size of the stripe. It is for this reason "
"the memory footprint of |TS| depends strongly on the size of the disk cache."
" Because the directory size does not change, neither does this memory "
"requirement so |TS| does not consume more memory as more content is stored "
"in the cache. If there is enough memory to run |TS| with an empty cache "
"there is enough to run it with a full cache."
msgstr ""
"追加点は、ディレクトリは常に最大のサイズにされることです。"
"一度ストライプは、ディレクトリサイズを固定し、二度と変更されないよう初期化されます。"
"このサイズは、ストライプのサイズに(大雑把に、線形に)関係します。"
"この理由は、 |TS| のメモリ使用量はディスクキャッシュのサイズに強く依存するためです。"
"ディレクトリサイズを変更しないため、このメモリ要求により、 |TS| がキャッシュに"
"保存されたコンテントより更に多くのメモリを消費することもありません。"
"もし 空のキャッシュを伴って |TS| を動作させる為に十分なメモリがあるなら、"
"フルキャッシュを伴ってそれを起動するのに十分あります。"

#: ../../arch/cache/cache-arch.en.rst:128
msgid ""
"Each entry stores an offset in the stripe and a size. The size stored in the"
" directory entry is an :ref:`approximate size <dir-size>` which is at least "
"as big as the actual data. Exact size data is stored in the fragment header "
"on disk."
msgstr ""
"各エントリは、ストライプやサイズのオフセットを保存します。"
"ディレクトリエントリに保存されるサイズは、少なくともディスクの実際のデータと同じ"
"くらい大きい :ref:`おおよそのサイズ <dir-size>` です。"
"正確なサイズデータは、ディスクのフラグメントヘッダ内に保存されます。"

#: ../../arch/cache/cache-arch.en.rst:133
msgid ""
"Data in HTTP headers cannot be examined without disk I/O. This includes the "
"original URL for the object. The original source of the cache ID is not "
"stored anywhere."
msgstr ""
"HTTPヘッダのデータは、ディスクI/Oなしには検査できません。"
"これは、オブジェクトのオリジナルURLが含まれます。"
"キャッシュIDのオリジナルソースは、どこにも保存されません。"

#: ../../arch/cache/cache-arch.en.rst:139
msgid ""
"The entries in a directory are grouped. The first level grouping is a "
"*bucket*. This is a fixed number (currently 4 - defined as ``DIR_DEPTH``) of"
" entries. The index generated from a cache ID is used as a bucket index (not"
" an entry index). Buckets are grouped in to *segments*. All segments in a "
"stripe have the same number of buckets. The number of segments in a stripe "
"is chosen so that each segment has as many buckets as possible without "
"exceeeding 65535 (2\\ :sup:`16`\\ -1) entries in a segment. Note that all "
"segments in the same stripe will have the same number of buckets."
msgstr ""
"ディレクトリ内のエントリはグループ化されています。"
"最初のレベルのグルーピングは、 *バケット* です。"
"これはエントリの固定の値(現在は4。 ``DIR_DEPTH`` として定義される)です。"
"キャッシュIDから生成されたインデックスは、バケットインデックス(エントリ"
"インデックスではない)として使用されます。"
"バケットは *セグメント* の中へグループ化されます。"
"ストライプの全セグメントは、バケットと同じ値を持ちます。"
"ストライプ内のセグメントの数は、各セグメントが、セグメント内のエントリが 65535 "
"(2\\ :sup:`16`\\ -1)を超過することが無いよう、可能な限り多いバケットを持つように"
"選ばれます。"
"同じストライプ内の全てのセグメントは、同じバケット数を持つよう注意してください。"

#: ../../arch/cache/cache-arch.en.rst:148
msgid ""
"Each entry has a previous and next index value which is used to link the "
"entries in the same segment. The index size is 16 bits which suffices to "
"index any entry in the same segment. The stripe header contains an array of "
"entry indices which are used as the roots of a free list. When a stripe is "
"initialized the first entry in each bucket is zeroed (marked unused) and all"
" other entries are put in the corresponding segment free list rooted in the "
"stripe header. In essence the first element of each fixed bucket is used as "
"a root for that bucket. The other entries in the fixed bucker are "
"preferentially preferred for adding to that bucket but this is not required."
" The segment free lists are initialized such that the extra bucket entries "
"are added in order - all the seconds, then the thirds, then the fourths. "
"Because the free lists are FIFOs this means extra entries will be selected "
"from the fourth entries across all the buckets first, then the thirds, etc. "
"This maximizes locality for bucket searching."
msgstr ""
"各エントリは、同一セグメントのエントリとリンクするために使用される、前と次の"
"インデックス値を持ちます。"
"インデックスサイズは、同じセグメントの任意のエントリのインデックスとして十分で"
"ある16ビットです。"
"ストライプヘッダは、フリーリストのルートとして使用されるエントリインデックスの"
"配列を含みます。"
"ストライプが初期化される時、各バケットの最初のエントリはゼロにされ(未使用だと"
"マークされ)、セグメントの全てのエントリは、ストライプヘッダのルートの"
"フリーリストへの関連付けがされます。"
"本質的には、各固定バケットの最初の要素は、そのバケットにルートとして使用されます。"
"固定バケットの他のエントリは、そのバケットに追加するため優先的に好まれますが、"
"これは必要ではありません。"
"エキストラバケットエントリが順番、全てが二番目の次に三番目、その次に四番目、に"
"追加されるように、セグメントフリーリストは初期化されます"
"フリーリストはFIFOであるため、これはエキストラエントリは、最初の次に三番目、"
"その他と全てのバケットを横断して、四番目のエントリから選択されるかもしれないことを"
"意味します。"
"これはバケット検索の局所性を最大化します。"

#: ../../arch/cache/cache-arch.en.rst:161
msgid ""
"Entries are removed from the free list when used and returned when no longer"
" in use. When a fragment needs to be put in to the directory the cache ID is"
" used to locate a bucket (which also determines the segment). If the first "
"entry in the bucket is marked unused, it is used. If not then the other "
"entries in the bucket are searched and if any are on the free list, that "
"entry is used. If none are available then the first entry on the segment "
"free list is used. This entry is attached to the bucket via the same next "
"and previous indices used for the free list so that it can be found when "
"doing a lookup of a cache ID."
msgstr ""
"使用され返される時、もはや使用されなくなった時に、エントリはこのリストから"
"削除されます。"
"エントリは、可能であれば、キャッシュキーによりインデックス化されたバケットから"
"割り当てられます。"
"バケットのエントリは最初に検索され、もしどれかがフリーリストにある場合、その"
"エントリが使用されます。。"
"もしセグメントの最初のエントリより使用出来るものが無い場合、フリーリストが使用"
"されます。"
"このエントリは、キャッシュIDの検索を行う時に見つけられるよう、フリーリストに"
"使用された同一の次もしくは前インデックスから、バケットへ取り付けられます。"

#: ../../arch/cache/cache-arch.en.rst:169
msgid "Storage Layout"
msgstr "ストレージレイアウト"

#: ../../arch/cache/cache-arch.en.rst:171
msgid ""
"The storage layout is the stripe metadata followed by cached content. The "
"metadata consists of three parts - the stripe header, the directory, and the"
" stripe footer. The metadata is stored twice. The header and the footer are "
"instances of :cpp:class:`VolHeaderFooter`. This is a stub structure which "
"can have a trailing variable sized array. This array is used as the segment "
"free list roots in the directory. Each contains the segment index of the "
"first element of the free list for the segment. The footer is a copy of the "
"header without the segment free lists. This makes the size of the header "
"dependent on the directory but not that of the footer."
msgstr ""
"ストレージレイアウトは、キャッシュされたコンテントにより追跡されるストライプの"
"メタデータです。"
"メタデータは三つの部分、ストライプヘッダ、ディレクトリ、ストライプフッタで"
"成立します。"
"メタデータは二度保存されます。"
"ヘッダとフッタは :cpp:class:`VolHeaderFooter` のインスタンスです。"
"これは、可変長配列を引きずるのに持てるスタブ構造です。"
"この配列は、ディレクトリ内のセグメントのフリーリストのルートとして使用されます。"
"それぞれはセグメントのフリーリストの、最初の要素のセグメントインデックスを"
"含みます。"
"フッタはセグメントフリーリストを伴わないヘッダのコピーです。"
"これはディレクトリに依存したヘッダのサイズを作成しますが、フッタは除きます。"

#: ../../arch/cache/cache-arch.en.rst:181
msgid "Each stripe has several values that describe its basic layout."
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:185
msgid "skip"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:184
msgid ""
"The start of stripe data. This represents either space reserved at the start"
" of a physical device to avoid problems with the host operating system, or "
"an offset representing use of space in the cache span by other stripes."
msgstr ""
"ストライプデータの開始地点です。"
"これは、ホストオペレーティングシステムによる問題を回避するための物理デバイスの"
"始点に予約されたスペース、もしくは他のストライプによって、キャッシュスパンの"
"スペースの使用を表現するオフセットのどちらかを表現します。"

#: ../../arch/cache/cache-arch.en.rst:188
msgid "start"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:188
msgid "The offset for the start of the content, after the stripe metadata."
msgstr "ストライプメタデータの後、コンテントの開始地点のためのオフセット"

#: ../../arch/cache/cache-arch.en.rst:191
msgid "length"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:191
msgid "Total number of bytes in the stripe. :cpp:member:`Vol::len`."
msgstr "ストライプのバイトの合計値。 :cpp:member:`Vol::len` "

#: ../../arch/cache/cache-arch.en.rst:194
msgid "data length"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:194
msgid ""
"Total number of blocks in the stripe available for content storage. "
":cpp:member:`Vol::data_blocks`."
msgstr ""
"コンテントストレージとして使用可能なストライプのブロックの合計値。"
":cpp:member:`Vol::data_blocks` "

#: ../../arch/cache/cache-arch.en.rst:196
msgid ""
"Great care must be taken with sizes and lengths in the cache code because "
"there are at least three different metrics (bytes, cache blocks, store "
"blocks) used in various places."
msgstr ""
"キャッシュコードの size や length を扱う場合、特に注意しなければなりません。"
"これらは様々な箇所で、少なくとも三つの違うメトリクス(バイト、キャッシュブロック、"
"ストアブロック)が使われているからです。"

#: ../../arch/cache/cache-arch.en.rst:198
msgid ""
"The total size of the directory (the number of entries) is computed by "
"taking the size of the stripe and dividing by the average object size. The "
"directory always consumes this amount of memory which has the effect that if"
" cache size is increased so is the memory requirement for |TS|. The average "
"object size defaults to 8000 bytes but can be configured using "
":ts:cv:`proxy.config.cache.min_average_object_size`. Increasing the average "
"object size will reduce the memory footprint of the directory at the expense"
" of reducing the number of distinct objects that can be stored in the cache "
"[#]_."
msgstr ""
"ディレクトリの合計サイズ(エントリの数)は、ボリュームのサイズを取得し、平均"
"オブジェクトサイズで除算することで計算されます。"
"もしキャッシュサイズが、 |TS| のためのメモリ要求がそうであるよう増加される場合、"
"ディレクトリは常に、その効果があるこのメモリ量を消費します。"
"平均オブジェクトサイズはデフォルトで8000バイトですが、 "
":ts:cv:`proxy.config.cache.min_average_object_size` を使うことで設定できます。"
"平均オブジェクトサイズを増加させることにより、キャッシュに保存する個別の"
"オブジェクトの数を減らす犠牲によって、ディレクトリのメモリ使用量を減らせる"
"でしょう。"

#: ../../arch/cache/cache-arch.en.rst:208
msgid ""
"The content area stores the actual objects and is used as a circular buffer "
"where new objects overwrite the least recently cached objects. The location "
"in a stripe where new cache data is written is called the *write cursor*. "
"This means that objects can be de facto evicted from cache even if they have"
" not expired if the data is overwritten by the write cursor. If an object is"
" overwritten this is not detected at that time and the directory is not "
"updated. Instead it will be noted if the object is accessed in the future "
"and the disk read of the fragment fails."
msgstr ""
"コンテントエリアは、実際のオブジェクトと最も最近キャッシュされた"
"ドキュメントを新たなドキュメントで上書きする循環バッファとして使用されます。"
"ストライプの新たなキャッシュデータの位置は、 *書込みカーソル* と呼ばれます。"
"これは、データが書込みカーソルによって上書きされる場合、たとえ失効して"
"いなくても、オブジェクトは事実上、キャッシュから立ち退かせることを意味します。"
"もしオブジェクトが上書きされる場合、これはその時は検出されず、ディレクトリは"
"更新されません。"
"代わりに、もしオブジェクトが将来アクセスされ、フラグメントのディスク読込みが"
"失敗する場合、警告されるでしょう。"

#: ../../arch/cache/cache-arch.en.rst:217
msgid "The write cursor and documents in the cache."
msgstr "キャッシュ内の書込みカーソルとドキュメント"

#: ../../arch/cache/cache-arch.en.rst:219
msgid "Cache data on disk is never updated."
msgstr "ディスク上のキャッシュデータは永遠に更新されません。"

#: ../../arch/cache/cache-arch.en.rst:221
msgid ""
"This is a key thing to keep in mind. What appear to be updates (such as "
"doing a refresh on stale content and getting back a 304) are actually new "
"copies of data being written at the write cursor. The originals are left as "
"\"dead\" space which will be consumed when the write cursor arrives at that "
"disk location. Once the stripe directory is updated (in memory!) the "
"original fragment in the cache is effectively destroyed. This is the general"
" space management techinque used in other cases as well. If an object needs "
"to removed from cache, only the directory needs to be changed. No other work"
" (and *particularly* no disk I/O) needs to be done."
msgstr ""
"これは心に留めておく重要な思考です。"
"更新されるように見えるもの（古くなったコンテンツをリフレッシュし、304を返す"
"ような）は、実際には書込みカーソルで書き込まれているデータの新しいコピーです。"
"オリジナルは、書込みカーソルがディスクのその位置に到着する時消費される、\"死んだ\""
"スペースとして残されます。"
"一旦ボリュームディレクトリが（メモリ内で！）更新されると、キャッシュ上のオリジナル"
"オブジェクトは効率的に破棄されます。"
"これは他のケースで同様に用いられる、一般的なスペース管理技術です。"
"もしオブジェクトをキャッシュから削除することが必要になる場合、ボリュームディレク"
"トリエントリのみ変更されます。"
"他の動作を行う必要はありません。（そして、 *特に* ディスクI/Oもありません）"

#: ../../arch/cache/cache-arch.en.rst:229
msgid "Object Structure"
msgstr "オブジェクト構造"

#: ../../arch/cache/cache-arch.en.rst:231
msgid ""
"Objects are stored as two types of data, metadata and content data. Metadata"
" is all the data about the object and the content and includes the HTTP "
"headers. The content data is the content of the object, the octet stream "
"delivered to the client as the object."
msgstr ""
"オブジェクトは二つのデータのタイプ、メタデータとコンテントデータとして保存されます。"
"メタデータは、HTTPヘッダを含む、オブジェクトとコンテントに関する全てのデータです。"
"コンテントデータはオブジェクトのコンテントで、オブジェクトとしてクライアントに"
"配信されるオクテットストリームです。"

#: ../../arch/cache/cache-arch.en.rst:235
msgid ""
"Objects are rooted in a :cpp:class:`Doc` structure stored in the cache. "
":cpp:class:`Doc` serves as the header data for a fragment and is contained "
"at the start of every fragment. The first fragment for an object is termed "
"the \"first ``Doc``\" and always contains the object metadata. Any operation"
" on the object will read this fragment first. The fragment is located by "
"converting the cache key for the object to a cache ID and then doing a "
"lookup for a directory entry with that key. The directory entry has the "
"offset and approximate size of the first fragment which is then read from "
"the disk. This fragment will contain the request header and response along "
"with overall object properties (such as content length)."
msgstr ""
"オブジェクトは、キャッシュに格納される :cpp:class:`Doc` 構造内のルートです。"
":cpp:class:`Doc` はフラグメントのためヘッダデータとして提供し、各フラグメントの"
"開始地点に含まれます。"
"これは \"ファースト ``Doc``\" と呼ばれ、常にメタデータに含まれます。"
"オブジェクトの任意の命令は、最初にこのフラグメントを読み込むでしょう。"
"そのフラグメントは、オブジェクトのキャッシュキーをキャッシュIDに変換することに"
"より配置され、その時そのキーを伴ってディレクトリエントリが検索されます。"
"ディレクトリエントリは、その時ディスクから読み込まれるファーストフラグメントの"
"オフセットとおおよそのサイズを持ちます。"
"このフラグメントは、全体のオブジェクトのプロパティ(コンテント長のような)に加えて、"
"リクエストヘッダとレスポンスを含むでしょう。"

#: ../../arch/cache/cache-arch.en.rst:245
msgid ""
"|TS| supports `varying content "
"<http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44>`_ for "
"objects. These are called *alternates*. All metadata for all alternates is "
"stored in the first fragment including the set of alternates and the HTTP "
"headers for them. This enables `alternate selection "
"<http://trafficserver.apache.org/docs/trunk/sdk/http-hooks-and-transactions"
"/http-alternate-selection.en.html>`_ to be done after the first ``Doc`` is "
"read from disk. An object that has more than one alternate will have the "
"alternate content stored separately from the first fragment. For objects "
"with only one alternate the content may or may not be in the same (first) "
"fragment as the metadata. Each separate alternate content is allocated a "
"directory entry and the key for that entry is stored in the first fragment "
"metadata."
msgstr ""
"|TS| は オブジェクト用に `コンテントの検証 "
"<http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44>`_"
"をサポートします。"
"これらを *オルタネイト* と呼びます。"
"全てのオルタネイトの全てのメタデータは、オルタネイトのセットとそれらの"
"HTTPヘッダを含むファーストフラグメントに格納されます。"
"これは、ファースト ``Doc`` がディスクから読込まれた後に、"
"`オルタネイトセクション <http://trafficserver.apache.org/docs/trunk/sdk/http-hooks-and-transactions/http-alternate-selection.en.html>`_ が実行され有効になります。"
"一個以上のオルタネイトを持つオブジェクトは、ファーストフラグメントとは別に保存された"
"オルタネイトコンテントを持ちます。"
"一つのオルタネイトのみ持つオブジェクトについては、コンテントはメタデータとしての"
"(最初の)フラグメントと同じになるかもしれないし、そうでもないかもしれません。"
"個々の分離されたオルタネイトコンテントは、ボリュームディレクトリエントリに"
"割り当てられ、エントリーのキーはファーストフラグメントのメタデータに保存されます。"

#: ../../arch/cache/cache-arch.en.rst:254
msgid ""
"Prior to version 4.0.1 the header data was stored in the "
":cpp:class:`CacheHTTPInfoVector` class which was marshaled to a variable "
"length area of the on disk image, followed by information about additional "
"fragments if needed to store the object."
msgstr ""
"バージョン 4.0.1 以前は、ヘッダデータは、もしオブジェクトを保存することが必要に"
"なった場合、追加のフラグメントについての情報により追跡されるディスクイメージの"
"可変長領域をまとめる :cpp:class:`CacheHTTPInfoVector` クラス内に保存されていました。"

#: ../../arch/cache/cache-arch.en.rst:261
msgid "``Doc`` layout 3.2.0"
msgstr "3.2.0 以前の ``Doc`` レイアウト"

#: ../../arch/cache/cache-arch.en.rst:263
msgid ""
"This had the problem that with only one fragment table it could not be "
"reliable for objects with more than one alternate [#]_. Therefore the "
"fragment data was moved from being a separate variable length section of the"
" metadata to being directly incorporated in to the "
":cpp:class:`CacheHTTPInfoVector`, yielding a layout of the following form."
msgstr ""
"これは、一つのフラグメントテーブルのみで、一つ以上のオルタネイト"
"を持つオブジェクトに対して正確な信頼性を持てない問題があります。"
"従って、以下の形式のレイアウトになるよう、フラグメントデータはメタデータの個別の"
"可変長セクションから、 :cpp:class:`CacheHTTPInfoVector` へ直接統合されるよう"
"移動されました。"

#: ../../arch/cache/cache-arch.en.rst:270
msgid "``Doc`` layout 4.0.1"
msgstr "4.0.1 の ``Doc`` レイアウト"

#: ../../arch/cache/cache-arch.en.rst:272
msgid ""
"Each element in the vector contains for each alternate, in addition to the "
"HTTP headers and the fragment table (if any), a cache key. This cache key "
"identifies a directory entry that is referred to as the \"earliest "
"``Doc``\". This is the location where the content for the alternate begins."
msgstr ""
"ベクターの各要素は、各オルタネイトに加え、HTTPヘッダと(もしあれば)フラグメント"
"テーブル、キャッシュキーを含みます。"
"このキャッシュキーは \"アーリスト ``Doc`` \" として参照されるボリュームディレクトリ"
"エントリを識別します。"
"これはオルタネイトのコンテントが始まる位置です。"

#: ../../arch/cache/cache-arch.en.rst:276
msgid ""
"When the object is first cached, it will have a single alternate and that "
"will be stored (if not too large) in first ``Doc``. This is termed a "
"*resident alternate* in the code. This can only happen on the initial store "
"of the object. If the metadata is updated (such as a ``304`` response to an "
"``If-Modified-Since`` request) then unless the object is small, the object "
"data will be left in the original fragment and a new fragment written as the"
" first fragment, making the alternate non-resident. \"Small\" is defined as "
"a length smaller than :ts:cv:`proxy.config.cache.alt_rewrite_max_size`."
msgstr ""
"オブジェクトが最初にキャッシュされたとき、それは単一のオルタネイトを持ち、(大き"
"すぎない場合は)ファースト ``Doc`` に格納されるでしょう。"
"これはコード中で *レジデントオルタネイト* と名付けられます。"
"レジデントオルタネイトは好ましく無く、今度はオブジェクトコンテントが分離される"
"ようヘッダ情報が更新されます。"

#: ../../arch/cache/cache-arch.en.rst:284
msgid ""
"The :cpp:class:`CacheHTTPInfoVector` is stored only in the first ``Doc``. "
"Subsequent ``Doc`` instances for the object, including the earliest ``Doc``,"
" should have an ``hlen`` of zero and if not, it is ignored."
msgstr ""
":cpp:class:`CacheHTTPInfoVector` はファースト ``Doc`` にのみ保存されます。"
"その後の ``Doc`` インスタンスは、ゼロの ``hlen`` を持つでしょう"

#: ../../arch/cache/cache-arch.en.rst:287
msgid ""
"Large objects are split in to multiple fragments when written to the cache. "
"This is indicated by a total document length that is longer than the content"
" in first ``Doc`` or an earliest ``Doc``. In such a case a fragment offset "
"table is stored. This contains the byte offset in the object content of the "
"first byte of content data for each fragment past the first (as the offset "
"for the first is always zero). This allows range requests to be serviced "
"much more efficiently for large objects, as intermediate fragments that do "
"not contain data in the range can be skipped. The last fragment in the "
"sequence is detected by the fragment size and offset reaching the end of the"
" total size of the object, there is no explicit end mark. Each fragment is "
"computationally chained from the previous in that the cache key for fragment"
" N is computed by::"
msgstr ""
"巨大なオブジェクトは、キャッシュに書き込まれる時に *フラグメント* "
"に分割されます。"
"各フラグメントはボリュームディレクトリの自身のエントリを持ちます。"
"これはドキュメント長の合計が、ファースト ``Doc`` もしくはアーリスト ``Doc``"
"のコンテントより長いことを示します。"
"これは、(最初のオフセットが常にゼロである)過去に最初だった各フラグメント毎の"
"コンテントデータの、最初のバイトのオブジェクトコンテント内の、"
"バイトオフセットを含みます。"
"これは、中間のフラグメントが、ファースト/アーリスト ``Doc`` の次にロードされた関連データを"
"伴う最初のフラグメントをスキップできることにより、巨大なオブジェクトの為に非常に"
"効率的に提供されるためのレンジリクエスト許可します。"
"シーケンスの最後のフラグメントは、フラグメントサイズとオフセットがオブジェクトの"
"合計サイズの最後に到達することにより検出されます。"
"明示的なエンドマークはありません。"
"各フラグメントは計算上は前のものと繋がっています。"
"フラグメントNのキャッシュキーは、以下により計算されます::"

#: ../../arch/cache/cache-arch.en.rst:298
msgid ""
"where ``next_key`` is a global function that deterministically computes a "
"new cache key from an existing cache key."
msgstr ""
"``next_key`` の部分は、既存のキャッシュキーから新しいキャッシュキーを決定論的に"
"計算する帯域関数です。"

#: ../../arch/cache/cache-arch.en.rst:300
msgid ""
"Objects with multiple fragments are laid out such that the data fragments "
"(including the earliest ``Doc``) are written first and the first ``Doc`` is "
"written last. When read from disk, both the first and earliest ``Doc`` are "
"validated (tested to ensure that they haven't been overwritten by the write "
"cursor) to verify that the entire document is present on disk (as they "
"bookend the other fragments - the write cursor cannot overwrite them without"
" overwriting at leastone of the verified ``Doc`` instances). Note that while"
" the fragments of a single object are ordered they are not necessarily "
"contiguous as data from different objects are interleaved as the data "
"arrives in |TS|."
msgstr ""
"複数のフラグメントを伴うオブジェクトは、(アーリスト ``Doc`` を含む)最初に"
"書き込まれたデータフラグメントと最後に書き込まれたファースト ``Doc`` のように、"
"レイアウトされます。"
"ディスクから読み込まれる時、ファースト、アーリストの ``Doc``"
"の両方は、全体のドキュメントがディスクに存在することを確認する(それら、他の"
"フラグメントのブックエンドとして、書込みカーソルは確認された ``Doc`` インスタンス"
"の少なくとも一つの上書き無しに、それらを上書き出来ません)ため、(それらが"
"書込みカーソルにより上書きされていない確認することにより試験されます)検証されます。"
"単一のオブジェクトのフラグメントは、異なるオブジェクトが |TS| に届いたデータ"
"として綴じ込められたデータとして、必然的に隣接しないよう整列されることに注意"
"してください。"

#: ../../arch/cache/cache-arch.en.rst:310
msgid "Multi-alternate and multi-fragment object storage"
msgstr "オブジェクトストレージの、複数のオルタネイトと複数のフラグメント"

#: ../../arch/cache/cache-arch.en.rst:314
msgid ""
"Documents which are \"pinned\" into the cache must not be overwritten so "
"they are \"evacuated\" from in front of the write cursor. Each fragment is "
"read and rewritten. There is a special lookup mechanism for objects that are"
" being evacuated so that they can be found in memory rather than the "
"potentially unreliable disk regions. The cache scans ahead of the write "
"cursor to discover pinned objects as there is a dead zone immediately before"
" the write cursor from which data cannot be evacuated. Evacuated data is "
"read from disk and placed in the write queue and written as its turn comes "
"up."
msgstr ""
"キャッシュへ \"ピン留め\" されるオブジェクトは、上書きされてはいけません。"
"そのため、それらは 書込みカーソルの前に\"退避\" させられます"
"各フラグメントは読み込まれ、再書込みされます。"
"潜在的に信頼性の低いディスク領域ではなく、メモリ内で発見できるよう、退避される"
"オブジェクトのための特別な検出メカニズムがあります。"
"ピン留めされたオブジェクトを発見するため、キャッシュは書込みカーソルより前にスキャンされます。"
"データを退避させることができない書込みカーソル直前のデットゾーンがあります。"
"退避されたデータはディスクから読み込まれ、書込みキューに置かれ、出番が来ると"
"書き込まれます。"

#: ../../arch/cache/cache-arch.en.rst:320
msgid ""
"It appears that objects can only be pinned via the :file:`cache.config` file"
" and if the :ts:cv:`proxy.config.cache.permit.pinning` is set to non-zero "
"(it is zero by default). Objects which are in use when the write cursor is "
"near use the same underlying evacuation mechanism but are handled "
"automatically and not via the explicit ``pinned`` bit in :cpp:class:`Dir`."
msgstr ""
"オブジェクトは、 :file:`cache.config` ファイルを経て、以下の値をゼロでない値"
"(デフォルトではゼロ)に設定した場合のみピン留めできます。::"

#: ../../arch/cache/cache-arch.en.rst:325
msgid ""
"It could, under certain circumstances, be accurate for none of the "
"alternates."
msgstr "それは、ある状況下では、オルタネイト無しに正確になりえます。"

#: ../../arch/cache/cache-arch.en.rst:328
msgid "Additional Notes"
msgstr "追加情報"

#: ../../arch/cache/cache-arch.en.rst:330
msgid "Some general observations on the data structures."
msgstr "データ構造のいくつかの概説。"

#: ../../arch/cache/cache-arch.en.rst:333
msgid "Cyclone buffer"
msgstr "循環バッファ"

#: ../../arch/cache/cache-arch.en.rst:335
msgid ""
"Because the cache is a cyclone cache objects are not preserved for an "
"indefinite time. Even if the object is not stale it can be overwritten as "
"the cache cycles through its volume. Marking an object as ``pinned`` "
"preserves the object through the passage of the write cursor but this is "
"done by copying the object across the gap, in effect re-storing it in the "
"cache. Pinning large objects or a large number objects can lead to a "
"excessive disk activity. The original purpose of pinning seems to have been "
"for small, frequently used objects explicitly marked by the administrator."
msgstr ""
"キャッシュが循環であるため、キャッシュオブジェクトは不定期間の保存はされません。"
"たとえオブジェクトが古くなくても、そのボリュームのキャッシュサイクルとして"
"上書き出来ます。"
"``ピン留め`` としてオブジェクトをマーキングすることにより、書込みカーソルの通過を"
"やり過ごし、しかしキャッシュ内で再保存をする効果によりギャップを埋めて、コピー"
"することによりこれが処理され、オブジェクトを保存します。"
"巨大なオブジェクトや大量のオブジェクトのピン留めは、過度のディスク動作を引き"
"起こす場合があります。"
"ピン留めの本来の目的は、頻繁に使用されるオブジェクトを管理者により明記的に"
"印付け、それを小さくすることだと思われます。"

#: ../../arch/cache/cache-arch.en.rst:341
msgid ""
"This means the purpose of expiration data on objects is simply to prevent "
"them from being served to clients. They are not in the standard sense "
"deleted or cleaned up. The space can't be immediately reclaimed in any event"
" because writing only happens at the write cursor. Deleting an object "
"consists only of removing the directory entries in the volume directory "
"which suffices to (eventually) free the space and render the document "
"inaccessible."
msgstr ""
"これは、オブジェクトの失効データがクライアントに提供されるのをを単に防ぐのが"
"目的であることを意味します。"
"それらは標準の感覚では削除されたかクリーンアップされていません。"
"書込みは書込みカーソルでのみ発生するので、どんなイベントにおいてもスペースは"
"直ちには取り戻されません。"
"オブジェクトの削除は、(結局)スペースを解放し、かつドキュメントをアクセス不可能に"
"するのに十分であるボリュームディレクトリのディレクトリエントリの削除からのみ"
"成り立ちます。"

#: ../../arch/cache/cache-arch.en.rst:346
msgid ""
"Historically the cache is designed this way because web content was "
"relatively small and not particularly consistent. The design also provides "
"high performance and low consistency requirements. There are no "
"fragmentation issues for the storage, and both cache misses and object "
"deletions require no disk I/O. It does not deal particularly well with long "
"term storage of large objects. See the :ref:`volume tagging` appendix for "
"details on some work in this area."
msgstr ""
"歴史的に、ウェブコンテンツは比較的小さく、特に一貫していなかったので、キャッシュは"
"この手段で設計されます。"
"この設計は高性能かつ低い一貫性の要求も提供します。"
"ストレージのフラグメンテーション問題は無く、またキャッシュミスやオブジェクト"
"削除はディスクI/Oを要求しません。"
"それは巨大なオブジェクトの長期間保存は特に扱いません。"
"この分野の幾つかの働きの詳細の付録 :ref:`volume tagging` を見てください。"

#: ../../arch/cache/cache-arch.en.rst:352
msgid "Disk Failure"
msgstr "ディスク障害"

#: ../../arch/cache/cache-arch.en.rst:354
msgid ""
"The cache is designed to be relatively resistant to disk failures. Because "
"each storage unit in each volume is mostly independent the loss of a disk "
"simply means that the corresponding :cpp:class:`Vol` instances (one per "
"cache volume that uses the storage unit) becomes unusable. The primary issue"
" is updating the volume assignment table to both preserve assignments for "
"objects on still operational volumes while distributing the assignments from"
" the failed disk to those operational volumes. This mostly done in::"
msgstr ""
"キャッシュは、ディスク障害に比較的強いように設計されます。"
"各ボリュームの各ストレージユニットはほとんど独立しているので、ディスクの損失は "
"対応する :cpp:class:`Vol` インスタンス(ストレージユニットを使うキャッシュ"
"ボリューム毎のそれ)が使えなくなることを単に意味します。"
"主な問題は、まだ運用中のボリューム上のオブジェクトのため、故障したディスクから"
"それらの運用中のボリューム割当の配布中に割当を両方保存するためのボリューム割当"
"テーブルの更新です。"
"これはほとんどこれで処理されます::"

#: ../../arch/cache/cache-arch.en.rst:358
msgid ""
"Restoring a disk to active duty is quite a bit more difficult task. Changing"
" the volume assignment of a cache key renders any currently cached data "
"inaccessible. This is obviouly not a problem when a disk has failed, but is "
"a bit trickier to decide which cached objects are to be de facto evicted if "
"a new storage unit is added to a running system. The mechanism for this, if "
"any, is still under investigation."
msgstr ""
"現役動作中のディスクにリストアするのは、かなり困難な作業です。"
"キャッシュキーのボリューム割当の変更は、現在のどのキャッシュデータもアクセス"
"不可能にします。"
"これは当然ながらディスクが故障した時の問題ではありませんが、新しいストレージ"
"ユニットが動作中のシステムに追加された場合は、どのキャッシュされたオブジェクトが"
"事実上追い出されるか決定するため少々扱いにくいです。"
"このためのメカニズムは、もし何かあれば、まだ調査下にあります。"

#: ../../arch/cache/cache-arch.en.rst:361
msgid "Implementation Details"
msgstr "実装の詳細"

#: ../../arch/cache/cache-arch.en.rst:364
msgid "Stripe Directory"
msgstr "ストライプディレクトリ"

#: ../../arch/cache/cache-arch.en.rst:368
msgid "The in memory volume directory entries are defined as described below."
msgstr ""
"メモリ内のボリュームディレクトリエントリは、以下の記述で定義されます。"

#: ../../arch/cache/cache-arch.en.rst:372
msgid "Defined in |P-CacheDir.h|_."
msgstr "|P-CacheDir.h|_ で定義される。"

#: ../../arch/cache/cache-arch.en.rst:375
msgid "Name"
msgstr "名前"

#: ../../arch/cache/cache-arch.en.rst:375
msgid "Type"
msgstr "型"

#: ../../arch/cache/cache-arch.en.rst:375
msgid "Use"
msgstr "用途"

#: ../../arch/cache/cache-arch.en.rst:377
msgid "offset"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:377
msgid "unsigned int:24"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:377
msgid "Offset of first byte of metadata (volume relative)"
msgstr "(ボリュームに関連した)メタデータの先頭バイトのオフセット"

#: ../../arch/cache/cache-arch.en.rst:378
msgid "big"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:378
msgid "unsigned in:2"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:378
msgid "Size multiplier"
msgstr "サイズの乗数"

#: ../../arch/cache/cache-arch.en.rst:379
msgid "size"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:379
msgid "unsigned int:6"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:379
msgid "Size"
msgstr "サイズ"

#: ../../arch/cache/cache-arch.en.rst:380
msgid "tag"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:380
msgid "unsigned int:12"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:380
msgid "Partial key (fast collision check)"
msgstr "(高速な衝突チェックの為の)キーの一部"

#: ../../arch/cache/cache-arch.en.rst:381
msgid "phase"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:381
#: ../../arch/cache/cache-arch.en.rst:382
#: ../../arch/cache/cache-arch.en.rst:383
#: ../../arch/cache/cache-arch.en.rst:384
msgid "unsigned int:1"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:381
msgid "Unknown"
msgstr "不明"

#: ../../arch/cache/cache-arch.en.rst:382
msgid "head"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:382
msgid "Flag: first fragment in an object"
msgstr "オブジェクト内のファーストフラグメントを示すフラグ"

#: ../../arch/cache/cache-arch.en.rst:383
#: ../../arch/cache/cache-arch.en.rst:312
msgid "pinned"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:383
msgid "Flag: document is pinned"
msgstr "ドキュメントがピン留めされていることを示すフラグ"

#: ../../arch/cache/cache-arch.en.rst:384
msgid "token"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:384
msgid "Flag: Unknown"
msgstr "不明なフラグ"

#: ../../arch/cache/cache-arch.en.rst:385
msgid "next"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:385
msgid "unsigned int:16"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:385
msgid "Segment local index of next entry."
msgstr "次エントリへのセグメントローカルなインデックス"

#: ../../arch/cache/cache-arch.en.rst:386
msgid "offset_high"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:386
msgid "inku16"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:386
msgid "High order offset bits"
msgstr "高順序オフセットビット"

#: ../../arch/cache/cache-arch.en.rst:389
msgid ""
"The stripe directory is an array of ``Dir`` instances. Each entry refers to "
"a span in the volume which contains a cached object. Because every object in"
" the cache has at least one directory entry this data has been made as small"
" as possible."
msgstr ""
"ストライプディレクトリは ``Dir`` インスタンスの配列です。"
"各エントリは、キャッシュされたオブジェクトを含むボリュームのスパンを参照します。"
"キャッシュ内の各オブジェクトは、少なくとも一つのディレクトリエントリを持つため、"
"このデータは可能な限り小さくされています。"

#: ../../arch/cache/cache-arch.en.rst:391
msgid ""
"The offset value is the starting byte of the object in the volume. It is 40 "
"bits long split between the *offset* (lower 24 bits) and *offset_high* "
"(upper 16 bits) members. Note that since there is a directory for every "
"storage unit in a cache volume, this is the offset in to the slice of a "
"storage unit attached to that volume."
msgstr ""
"オフセット値はボリューム内のオブジェクトの開始バイトです。"
"それは、 *offset* (下位24ビット) と *offset_high* (上位16ビット) メンバに"
"渡って分割された40ビット長です。"
"キャッシュボリュームの各ストレージユニットのためのディレクトリが存在するので、"
"これはボリュームに取り付けられたストレージユニットの一部分へのオフセットで"
"あることに注意してください。"

#: ../../arch/cache/cache-arch.en.rst:395
msgid ""
"The *size* and *big* values are used to calculate the approximate size of "
"the span which contains the object. This value is used as the number of "
"bytes to read from storage at the offset value. The exact size is contained "
"in the object metadata in :cpp:class:`Doc` which is consulted once the read "
"has completed. For this reason the approximate size needs to be at least as "
"large as the actual size but can be larger, at the cost of reading the "
"extraneous bytes."
msgstr ""
"*size* と *big* 値は、オブジェクトを含むスパンの大まかなサイズを計算する為に"
"使用されます。"
"この値は、オフセット値において、ストレージから読み込むためのバイト数として"
"使用されます。"
"正確なサイズは、読込みが完了した時に一度参照される :cpp:class:`Doc` の"
"オブジェクトメタデータに含まれます。"
"この理由として、大まかなサイズは少なくとも実際のデータと同じくらい大きくする"
"必要が有り、しかし無関係のバイトの読込みのコスト大きくできることがあります。"

#: ../../arch/cache/cache-arch.en.rst:397
msgid ""
"The computation of the approximate size of the fragment is defined as::"
msgstr ""
"フラグメントの大まかなサイズの計算は、以下のように定義されます。::"

#: ../../arch/cache/cache-arch.en.rst:401
msgid ""
"where ``CACHE_BLOCK_SHIFT`` is the bit width of the size of a basic cache "
"block (9, corresponding to a sector size of 512). Therefore the value with "
"current defines is::"
msgstr ""
"``CACHE_BLOCK_SHIFT`` の部分は、基本キャッシュブロックのサイズのビット幅"
"(9、512のセクタサイズに関連づけられる) です。"
"従って、その値は現在は以下のように定義されます。::"

#: ../../arch/cache/cache-arch.en.rst:405
msgid "Because *big* is 2 bits the values for the multiplier of *size* are"
msgstr "*big* は2ビットであるため、*size* の乗数の値は、"

#: ../../arch/cache/cache-arch.en.rst:410
msgid "*big*"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:410
msgid "Multiplier"
msgstr "乗数"

#: ../../arch/cache/cache-arch.en.rst:410
msgid "Maximum Size"
msgstr "最大サイズ"

#: ../../arch/cache/cache-arch.en.rst:412
msgid "0"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:412
msgid "512 (2^9)"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:412
#: ../../arch/cache/cache-arch.en.rst:414
msgid "32768 (2^15)"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:413
msgid "1"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:413
msgid "4096 (2^12)"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:413
#: ../../arch/cache/cache-arch.en.rst:415
msgid "262144 (2^18)"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:414
msgid "2"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:414
msgid "2097152 (2^21)"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:415
msgid "3"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:415
msgid "16777216 (2^24)"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:418
msgid ""
"Note also that *size* is effectively offset by one, so a value of 0 "
"indicates a single unit of the multiplier."
msgstr ""
"*size* も何かに効率的なオフセットであり、そのため0の値は乗数の単一ユニット示す"
"ことに注意してください。"

#: ../../arch/cache/cache-arch.en.rst:422
msgid "The target fragment size can set with the :file:`records.config` value"
msgstr ""
"ターゲットフラグメントサイズは、 :file:`records.config` の値で設定できます。"

#: ../../arch/cache/cache-arch.en.rst:424
msgid "``proxy.config.cache.target_fragment_size``"
msgstr ""

#: ../../arch/cache/cache-arch.en.rst:426
msgid ""
"This value should be chosen so that it is a multiple of a :ref:`cache entry "
"multiplier <big-mult>`. It is not necessary to make it a power of 2 [#]_. "
"Larger fragments increase I/O efficiency but lead to more wasted space. The "
"default size (1M, 2^20) is a reasonable choice in most circumstances altough"
" in very specific cases there can be benefit from tuning this parameter. "
"|TS| imposes an internal maximum of a 4194232 bytes which is 4M (2^22) less "
"the size of a struct :cpp:class:`Doc`. In practice then the largest "
"reasonable target fragment size is 4M - 262144 = 3932160."
msgstr ""
":ref:`キャッシュエントリ乗数<big-mult>` の倍数になるように、この値は選ばれる"
"べきです。"
"それは2の冪乗にする必要はありません。"
"巨大なフラグメントはI/Oの効率を向上しますが、より余分なスペースを読み込みます。"
"デフォルトサイズ(1M, 2^20)は、様々な特定ケースを通して、このパラメータを合わせる"
"ことにより恩恵が得られる、ほとんどの環境で合理的な選択です。"
"|TS| は、 :cpp:class:`Doc` 構造のサイズより少ない4M(2^22) である 4194232 バイトの"
"内部的な最大値を課します。"
"事実上、その後の最大の合理的なターゲットフラグメントサイズは"
"4M - 262144 = 3932160 です。"

#: ../../arch/cache/cache-arch.en.rst:432
msgid ""
"When a fragment is stored to disk the size data in the cache index entry is "
"set to the finest granularity permitted by the size of the fragment. To "
"determine this consult the :ref:`cache entry multipler <big-mult>` table, "
"find the smallest maximum size that is at least as large as the fragment. "
"That will indicate the value of *big* selected and therefore the granularity"
" of the approximate size. That represents the largest possible amount of "
"wasted disk I/O when the fragment is read from disk."
msgstr ""
"フラグメントがディスクへ保存される時、キャッシュインデックスエントリのサイズ"
"データは、フラグメントのサイズにより許容される非常に良い粒度で設定されます。"
"これが :ref:`キャッシュエントリ乗数 <big-mult>` テーブルを参照する決定するため、"
"少なくともフラグメントと同じくらい大きな、最も小さな最大サイズを検索します。"
"それは選択された *big* の値、従って大まかなサイズの粒度を索引するでしょう。"
"フラグメントがディスクから読み込まれる時、それは可能な限り最大の余分な"
"ディスクI/Oの量を表します。"

#: ../../arch/cache/cache-arch.en.rst:438
msgid ""
"The cache index entry size is used only for reading the fragment from disk. "
"The actual size on disk, and the"
msgstr ""
"キャッシュインデックスエントリサイズは、ディスクからのフラグメントの"
"読込みのみに使用されます。"

#: ../../arch/cache/cache-arch.en.rst:439
msgid ""
"amount of cache space consumed, is the actual size of the content rounded up"
" to the disk sector size (default 512 bytes)."
msgstr ""
"ディスク上の実際のサイズ、そしてキャッシュスペースが消費された量は、"
"ディスクセクタサイズ(でフォルトでは512バイト)に集められたコンテントの"
"実際のサイズです。"

#: ../../arch/cache/cache-arch.en.rst:444
msgid ""
"The set of index entries for a volume are grouped in to *segments*. The "
"number of segments for an index is selected so that there are as few "
"segments as possible such that no segment has more than 2^16 entries. Intra-"
"segment references can therefore use a 16 bit value to refer to any other "
"entry in the segment."
msgstr ""
"ボリュームの為のインデックスエントリのセットは、 *セグメント* へグループ化されます。"
"インデックスのセグメントの数は、それらが2^16エントリを超えるセグメント数でないよう"
"可能な限り少ないセグメントにするために選択されます。"
"内部セグメントはそのため、セグメントの任意の他のエントリを参照する為に16ビット値を"
"使用できます。"

#: ../../arch/cache/cache-arch.en.rst:448
msgid ""
"Index entries in a segment are grouped *buckets* each of ``DIR_DEPTH`` "
"(currently 4) entries. These are handled in the standard hash table way, "
"giving somewhat less than 2^14 buckets per segment."
msgstr ""
"セグメントのインデックスエントリは、 ``DIR_DEPTH`` (現在は4)エントリ毎に"
"グループ化されます。"
"これらは、セグメント毎2^14以下のバケットを与えるよう、標準的なハッシュテーブルの"
"方法で扱われます"

#: ../../arch/cache/cache-arch.en.rst:451
msgid "The comment in :file:`records.config` is simply wrong."
msgstr ""
":file:`records.config` のコメントは単純に間違っています。"

#: ../../arch/cache/cache-arch.en.rst:456
msgid "Directory Probing"
msgstr "ディレクトリ検査"

#: ../../arch/cache/cache-arch.en.rst:458
msgid ""
"Directory probing is locating a specific directory entry in the stripe "
"directory based on a cache ID. This is handled primarily by the function "
":cpp:func:`dir_probe()`. This is passed the cache ID (:arg:`key`), a stripe "
"(:arg:`d`), and a last collision (:arg:`last_collision`). The last of these "
"is an in and out parameter, updated as useful during the probe."
msgstr ""
"ディレクトリ検査は、キャッシュIDに基づくストライプディレクトリの特定のディレクトリ"
"エントリに配置します。"
"これは主に、 :cpp:func:`dir_probe()` 関数によって扱われます。"
"これはキャッシュID(:arg:`key`)、ストライプ(:arg:`d`)、そして最後の"
"コリジョン(:arg:`last_collision`)をパスされます。"
"これらの最後はパラメータを入ったり出たりし、検証の間に役立つよう更新されます。"

#: ../../arch/cache/cache-arch.en.rst:463
msgid ""
"Given an ID, the top half (64 bits) is used as a :ref:`segment <dir-"
"segment>` index, taken modulo the number of segments in the directory. The "
"bottom half is used as a :ref:`bucket <dir-bucket>` index, taken modulo the "
"number of buckets per segment. The :arg:`last_collision` value is used to "
"mark the last matching entry returned by `dir_probe`."
msgstr ""
"与えられたIDの、上位の半分(64ビット)は、 :ref:`セグメント <dir-segment>` イン"
"デックスとして使用され、ディレクトリのセグメントの数のモジュロとして扱われます。"
"下位の半分は :ref:`バケット <dir-bucket>` インデックスとして使用され、"
"セグメント毎のバケットの数のモジュロとして扱われます。"
":arg:`last_collision` の値は、 `dir_probe` によって返される、最後に合致する"
"エントリをマークするために使用されます。"

#: ../../arch/cache/cache-arch.en.rst:467
msgid ""
"After computing the appropriate bucket, the entries in that bucket are "
"searched to find a match. In this case a match is detected by comparison of "
"the bottom 12 bits of the cache ID (the *cache tag*). The search starts at "
"the base entry for the bucket and then proceeds via the linked list of "
"entries from that first entry. If a tag match is found and there is no "
":arg:`collision` then that entry is returned and :arg:`last_collision` is "
"updated to that entry. If :arg:`collision` is set, then if it isn't the "
"current match the search continues down the linked list, otherwise "
":arg:`collision` is cleared and the search continues. The effect of this is "
"that matches are skipped until the last returned match "
"(:arg:`last_collision`) is found, after which the next match (if any) is "
"returned. If the search falls off the end of the linked list then a miss "
"result is returned (if no last collision), otherwise the probe is restarted "
"after clearing the collision on the presumption that the entry for the "
"collision has been removed from the bucket. This can lead to repeats among "
"the returned values but guarantees that no valid entry will be skipped."
msgstr ""
"適切なバケットを算出した後、バケットのエントリは合致するものを探すために"
"検索されます。この場合、合致がキャッシュキーの下位 12 ビット(*キャッシュタグ*)"
"の比較によって検出されます。検索はバケットのベースエントリから開始して、"
"その後最初のエントリからの、エントリの連結リストから進めます。もしタグの合致が"
"発見され、 :arg:`collision` が無いなら、その後エントリは返され、そのエントリ"
"への :arg:`last_collision` が更新されます。もし、 :arg:`collision` がセット"
"されていたら、次にもし現在の合致が、連結リストの最後まで検索してもなかった"
"ことがない場合、 :arg:`collision` はクリアされ、検索は継続します。この効果は、"
"最後に (:arg:`last_collision`) が発見される合致が返されるまで、合致が"
"スキップされ、その後に次の合致が(もしあるなら)返されます。もし検索が連結"
"リストの最後に落ちて、その時結果の返却(もし最後の衝突がないなら)に失敗して"
"いないと、検査は、衝突の為のエントリがバケットから削除されていること"
"想定の上で、衝突を解消した後に再開されます。これは、値が返される間に繰り返す"
"ようにできますが、正常なエントリがスキップされることがないことを保証します。"

#: ../../arch/cache/cache-arch.en.rst:478
msgid ""
"Last collision can therefore be used to restart a probe at a later time. "
"This is important because the match returned may not be the actual object - "
"although the hashing of the cache ID to a bucket and the tag matching is "
"unlikely to create false positives, that is possible. When a fragment is "
"read the full cache ID is available and checked and if wrong, that read can "
"be discarded and the next possible match from the directory found because "
"the cache virtual connection tracks the last collision value."
msgstr ""
"最後のコリジョンは従って、後で検査を再開するために使用できます。これは返された"
"これは重要です。なぜなら、合致が、実際のオブジェクトではないかもしれない"
"ためです。 - バケットへのキャッシュ ID とタグ合致のハッシュ化が、偽陽性を"
"作成しそうに無いにも関わらず、 それは可能です。フラグメントが読み込まれる際、"
"キャッシュ ID の全体は使用可能であり、誤っている場合、チェックされます。"
"その読込みは破棄でき、キャッシュ仮想接続は最後の衝突値を追跡するため、"
"次のディレクトリから可能な合致が検索されます。"

#: ../../arch/cache/cache-arch.en.rst:486
msgid "Cache Operations"
msgstr "キャッシュオペレーション"

#: ../../arch/cache/cache-arch.en.rst:488
msgid ""
"Cache activity starts after the HTTP request header has been parsed and "
"remapped. Tunneled transactions do not interact with the cache because the "
"headers are never parsed."
msgstr ""
"キャッシュアクティビティは、 HTTP リクエストヘッダがパースされ、リマップ"
"されてから開始します。トンネルされたトランザクションは、ヘッダがパースされる"
"ことがないため、キャッシュに作用しません。"

#: ../../arch/cache/cache-arch.en.rst:490
msgid ""
"To understand the logic we must introduce the term \"cache valid\" which "
"means something that is directly related to an object that is valid to be "
"put in the cache (e.g. a ``DELETE`` which refers to a URL that is cache "
"valid but cannot be cached itself). This is important because |TS| computes "
"cache validity several times during a transaction and only performs cache "
"operations for cache valid results. The criteria used changes during the "
"course of the transaction as well. This is done to avoid the cost of cache "
"activity for objects that cannot be in the cache."
msgstr ""
"ロジックを理解するため、\"キャッシュバリッド\"という用語を紹介しなければ"
"いけません。これはキャッシュに置かれるのに有効なオブジェクトに、直接"
"関連づけられているものを意味します。(例えば、 URLを参照する ``DELETE`` "
"はキャッシュバリッドですが、それ自身はキャッシュできません) |TS| は"
"トランザクション中に何度かキャッシュの正当性を計算し、キャッシュ"
"バリッド結果のためにキャッシュオペレーションのみ行うため、重要です。"
"基準は、トランザクションの進行の間に、同様に変更に使用されます。これは"
"キャッシュできないオブジェクトの為のキャッシュアクティビティのコストを"
"避けるために完了します。"

#: ../../arch/cache/cache-arch.en.rst:492
msgid ""
"The three basic cache operations are lookup, read, and write. We will take "
"deleting entries as a special case of writing where only the volume "
"directory is updated."
msgstr ""
"キャッシュオペレーションの3 つの基礎は、ルックアップ、リード、そして"
"ライトです。我々はボリュームディレクトリが更新されるのみの箇所への書き込みの"
"特殊なケースとしてエントリの削除を行うでしょう。"

#: ../../arch/cache/cache-arch.en.rst:494
msgid ""
"After the client request header is parsed and is determined to be "
"potentially cacheable, a `cache lookup`_ is done. If successful a `cache "
"read`_ is attempted. If either the lookup or the read fails and the content "
"is considered cacheable then a `cache write`_ is attempted."
msgstr ""
"クライアントリクエストヘッダがパースされ、キャッシュできると決定された後、 "
"`キャッシュルックアップ`_ が行われます。成功した場合、 `キャッシュリード`_ が試みら"
"れます。ルックアップかリードのいずれかが失敗する、もしくはコンテントがキャッシュ"
"できると判断される場合、 `キャッシュライト`_  が試みられます。"

#: ../../arch/cache/cache-arch.en.rst:497
msgid "Cacheability"
msgstr "キャッシャビリティ"

#: ../../arch/cache/cache-arch.en.rst:499
msgid ""
"The first thing done with a request with respect to cache is to determine "
"whether it is potentially a valid object for the cache. After initial "
"parsing and remapping this check is done primarily to detect a negative "
"result because if so all further cache processing is skipped -- it will not "
"be put in to the cache nor will a cache lookup be done. There are a number "
"of prerequisites along with configuration options to change them. Additional"
" cacheability checks are done later in the process when more is known about "
"the transaction (such as plugin operations and the origin server response). "
"Those checks are described as appropriate in the sections on the relevant "
"operations."
msgstr ""
"キャッシュへの考慮を伴うリクエストと共に最初に行われるのは、潜在的に"
"キャッシュするのに有効なオブジェクトであるかどうかを決定することです。初期の"
"パースとリマップの後、このチェックは、主にネガティブな結果を検出するために"
"行われます。これは、全ての後のキャッシュ処理がスキップされる場合のためです。"
" -- それはキャッシュに配置されず、キャッシュルックアップが完了するはずです。"
"それらを変更する設定オプションと共に、必要条件の数があります。追加の"
"キャッシャビリティチェックは、より多くのトランザクションについて知られている処理"
"(プラグインオペレーションやオリジンサーバレスポンスのような)以降に完了されます。"
"それらのチェックは関連するオペレーションのセクションで適切に記述されます。"

#: ../../arch/cache/cache-arch.en.rst:501
msgid "The set of things which can affect cacheability are"
msgstr "キャッシャビリティに影響できる項目のセットは、"

#: ../../arch/cache/cache-arch.en.rst:503
msgid "Built in constraints"
msgstr "ビルドイン制約"

#: ../../arch/cache/cache-arch.en.rst:504
msgid "Settings in :file:`records.config`"
msgstr ":file:`records.config` の設定"

#: ../../arch/cache/cache-arch.en.rst:505
msgid "Settings in :file:`cache.config`"
msgstr ":file:`cache.config` の設定"

#: ../../arch/cache/cache-arch.en.rst:506
msgid "Plugin operations"
msgstr "プラグインオペレーション"

#: ../../arch/cache/cache-arch.en.rst:508
msgid ""
"The initial internal checks, along with their :file:`records.config` "
"overrides[#]_, are done in::"
msgstr ""
"初期の内部チェック、それらの :file:`records.config` を伴ったオーバー"
"ライドは以下のように完了します::"

#: ../../arch/cache/cache-arch.en.rst:512
msgid "The checks that are done are"
msgstr "チェックは以下のように行われます。"

#: ../../arch/cache/cache-arch.en.rst:517
msgid "Cacheable Method"
msgstr "キャッシュ可能なメソッド"

#: ../../arch/cache/cache-arch.en.rst:515
msgid ""
"The request must be one of ``GET``, ``HEAD``, ``POST``, ``DELETE``, ``PUT``."
msgstr "リクエストは、 ``GET``, ``HEAD``, ``POST``, ``DELETE``, ``PUT`` の"
"一つでなければなりません。"

#: ../../arch/cache/cache-arch.en.rst:517
msgid "See ``HttpTransact::is_method_cache_lookupable()``."
msgstr "``HttpTransact::is_method_cache_lookupable()`` を見てください。"

#: ../../arch/cache/cache-arch.en.rst:531
msgid "Dynamic URL"
msgstr "ダイナミック URL"

#: ../../arch/cache/cache-arch.en.rst:520
msgid ""
"|TS| tries to avoid caching dynamic content because it's dynamic. A URL is "
"considered dynamic if it"
msgstr ""
"動的であるため、 |TS| は動的コンテンツのキャッシングを避けようとします。"
"もし以下のようなら、 URL は動的であると考えられます。"

#: ../../arch/cache/cache-arch.en.rst:522
msgid "is not ``HTTP`` or ``HTTPS``"
msgstr "``HTTP`` や ``HTTPS`` ではない"

#: ../../arch/cache/cache-arch.en.rst:523
msgid "has query parameters"
msgstr "クエリパラメータを含む"

#: ../../arch/cache/cache-arch.en.rst:524
msgid "ends in ``asp``"
msgstr "``asp`` で終わる"

#: ../../arch/cache/cache-arch.en.rst:525
msgid "has ``cgi`` in the path"
msgstr "パスの中に ``cgi`` を含む"

#: ../../arch/cache/cache-arch.en.rst:527
msgid "This check can be disabled by setting a non-zero value for::"
msgstr "このチェックは、以下にゼロでない値を設定することで無効にできます::"

#: ../../arch/cache/cache-arch.en.rst:531
msgid ""
"In addition if a TTL is set for rule that matches in :file:`cache.config` "
"then this check is not done."
msgstr ""
"加えて、もし :file:`cache.config` に合致するルールに TTL が設定されていたら、"
"このチェックは行われません。"

#: ../../arch/cache/cache-arch.en.rst:534
msgid "Range Request"
msgstr "レンジリクエスト"

#: ../../arch/cache/cache-arch.en.rst:534
msgid ""
"Cache valid only if :ts:cv:`proxy.config.http.cache.range.lookup` in "
":file:`records.config` is non-zero. This does not mean the range request can"
" be cached, only that it might be satisfiable from the cache."
msgstr ""
"キャッシュバリッドは :file:`records.config` の "
":ts:cv:`proxy.config.http.cache.range.lookup` を除き、ゼロでない値です。"
"これは、レンジリクエストはキャッシュから満たされるかもしれないのみならず、"
"キャッシュできる事を意味しません。"

#: ../../arch/cache/cache-arch.en.rst:536
msgid ""
"A plugin can call :c:func:`TSHttpTxnReqCacheableSet()` to force the request "
"to be viewed as cache valid."
msgstr ""
"プラグインは、リクエストがキャッシュバリッドとして見なされる事を強制する"
"ため :c:func:`TSHttpTxnReqCacheableSet()` を呼び出せます。"

#: ../../arch/cache/cache-arch.en.rst:538
msgid ""
"The code appears to check :file:`cache.config` in this logic by setting the "
"``does_config_permit_lookup`` in the ``cache_info.directives`` of the state "
"machine instance but I can find no place where the value is used. The "
"directive ``does_config_permit_storing`` is set and later checked so the "
"directive (from the administrator point of view) is effective in preventing "
"caching of the object."
msgstr ""
"コードでは、このロジックの中で、ステートマシンインスタンスの "
"``cache_info.directives`` の中の ``does_config_permit_lookup`` を設定することに"
"より :file:`cache.config` をチェックするよう見えますが、私はその値が使用されて"
"いる箇所を発見できません。 ``does_config_permit_storing`` ディレクティブが設定され、"
"後にチェックされるので、そのディレクティブは(管理者の観点から)オブジェクトの"
"キャッシングを妨げるのに効果的です。"

#: ../../arch/cache/cache-arch.en.rst:541
msgid "Cache Lookup"
msgstr "キャッシュルックアップ"

#: ../../arch/cache/cache-arch.en.rst:543
msgid ""
"If the initial request is not determined to be cache invalid then a lookup "
"is done. Cache lookup determines if an object is in the cache and if so, "
"where it is located. In some cases the lookup proceeds to read the first "
"``Doc`` from disk to verify the object is still present in the cache."
msgstr ""
"初期リクエストが、キャッシュが不正確であると決定されなかった場合、ルックアップが"
"実行されます。キャッシュルックアップは、もしオブジェクトがキャッシュの中にある"
"なら、配置される場所を決定します。幾つかのケースでは、ルックアップは、まだ"
"キャッシュに保存されているオブジェクトを検証するため、ディスクから"
"ファースト ``Doc`` を読み込むために続行します。"

#: ../../arch/cache/cache-arch.en.rst:545
msgid "There are three basic steps to a cache lookup."
msgstr "キャッシュルックアップまで、3つの基礎的なステップがあります。"

#: ../../arch/cache/cache-arch.en.rst:547
msgid "The cache key is computed."
msgstr "キャッシュキーが計算されます。"

#: ../../arch/cache/cache-arch.en.rst:549
msgid ""
"This is normally computed using the request URL but it can be overridden "
":ref:`by a plugin <cache-key>` . As far as I can tell the cache index string"
" is not stored anywhere, it presumed computable from the client request "
"header."
msgstr ""
"これは通常、リクエスト URL を用いて計算されますが、 "
":ref:`プラグインによって <cache-key>` オーバーライドできます。私がキャッシュ"
"インデックス文字列がどこにも保存されない事を教えられる限り、クライアント"
"リクエストヘッダから計算可能であると推定されます。"

#: ../../arch/cache/cache-arch.en.rst:551
msgid "The cache stripe is determined (based on the cache key)."
msgstr "キャッシュストライプは(キャッシュキーに基づいて)決定されます。"

#: ../../arch/cache/cache-arch.en.rst:553
msgid ""
"The cache key is used as a hash key in to an array of :cpp:class:`Vol` "
"instances. The construction and arrangement of this array is the essence of "
"how volumes are assigned."
msgstr ""
"キャッシュキーは、 :cpp:class:`Vol` インスタンスの配列の中で、ハッシュキー"
"として使用されます。この配列の生成と配置は、ボリュームの割り当てられ方の"
"本質です。"

#: ../../arch/cache/cache-arch.en.rst:555
msgid ""
"The cache stripe directory :ref:`is probed <dir-probe>` using the index key "
"computed from the cache key."
msgstr ""
"インデックスキーを用いて :ref:`検証された <dir-probe>` キャッシュストライプ"
"ディレクトリは、キャッシュキーから計算されます。"

#: ../../arch/cache/cache-arch.en.rst:557
msgid ""
"Various other lookaside directories are checked as well, such as the "
":ref:`aggregation buffer <aggregation-buffer>`."
msgstr ""
"様々な他のルックアサイドディレクトリは、 "
":ref:`集約バッファ <aggregation-buffer>` と同様にチェックされます。"

#: ../../arch/cache/cache-arch.en.rst:559
msgid ""
"If the directory entry is found the first ``Doc`` is read from disk and "
"checked for validity."
msgstr ""
"ディレクトリエントリが発見された場合、ファースト ``Doc`` はディスクから"
"読み込まれ、正当性が検証されます。"

#: ../../arch/cache/cache-arch.en.rst:561
msgid ""
"This is done in :cpp:func:`cachevc::openreadstarthead()` or "
":cpp:func:`CacheVC::openReadStartEarliest()` which are tightly coupled "
"methods."
msgstr ""
"これは 強く結びついたメソッドである :cpp:func:`cachevc::openreadstarthead()` "
"もしくは :cpp:func:`CacheVC::openReadStartEarliest()` の中で実行されます。"

#: ../../arch/cache/cache-arch.en.rst:563
msgid ""
"If the lookup succeeds then a more detailed directory entry (struct "
":cpp:class:`OpenDir`) is created. Note that the directory probe includes a "
"check for an already extant ``OpenDir`` which if found is returned without "
"additional work."
msgstr ""
"もしルックアップが成功したら、更に詳細なディレクトリエントリ"
"(:cpp:class:`OpenDir`)が生成されます。ディレクトリ検査は、追加作業無しに"
"返される、既に現存している ``OpenDir`` が見つかった場合、そのチェックを含む"
"ことに注意してください。"

#: ../../arch/cache/cache-arch.en.rst:566
msgid "Cache Read"
msgstr "キャッシュリード"

#: ../../arch/cache/cache-arch.en.rst:568
msgid ""
"Cache read starts after a successful `cache lookup`_. At this point the "
"first ``Doc`` has been loaded in to memory and can be consulted for "
"additional information. This will always contain the HTTP headers for all "
"alternates of the object."
msgstr ""
"キャッシュリードは、 `キャッシュルックアップ`_ が成功した後に開始します。"
"この点で、ファースト ``Doc`` はメモリへ読み込まれ、追加情報の為に問い合わせ"
"られます。これは、常にオブジェクトの全オルタネイトの HTTP ヘッダを含む"
"でしょう。"

#: ../../arch/cache/cache-arch.en.rst:0
msgid "Read while write"
msgstr "ライト中リード"

#: ../../arch/cache/cache-arch.en.rst:572
msgid ""
"There is provision in the code to support \"read while write\", that is "
"serving an object from cache in one transaction while it is being written in"
" another. It is unclear to me if this actually works. It must specifically "
"enabled in :file:`records.config` and if not, a cache read will fail if the "
"object is currently be written or updated."
msgstr ""
"\"ライト中リード\" をサポートする為のコードが用意されています。これは、"
"1 トランザクション内で、他で書き込まれている最中に、キャッシュからオブジェクト"
"を配信します。これが実際に動作していても、私には明らかにされません。それは"
"特別に :file:`records.config` で有効にしなければならず、これを行わない場合は、"
"オブジェクトが現在書き込まれている、もしくは更新されている場合、キャッシュ"
"リードに失敗するでしょう。"

#: ../../arch/cache/cache-arch.en.rst:574
msgid ""
"At this point an alternate for the object is selected. This is done by "
"comparing the client request to the stored response headers, but it can be "
"controlled by a plugin using ``TS_HTTP_ALT_SELECT_HOOK``."
msgstr ""
"この点で、オブジェクトのオルタネイトは選択されます。これは、保存されたレスポンス"
"ヘッダへのクライアントリクエストの比較によって行われますが、 "
"``TS_HTTP_ALT_SELECT_HOOK`` を使用するプラグインによって制御できます。"

#: ../../arch/cache/cache-arch.en.rst:576
msgid ""
"The content can now be checked to see if it is stale by calculating the "
"\"freshness\" of the object. This is essential checking how old the object "
"is by looking at the headers and possibly other metadata (note the headers "
"can't be checked until we've selected an alternate)."
msgstr ""
"コンテントが、オブジェクトの \"新鮮さ\" の計算によって古い場合は、"
"この時、閲覧するためにチェックできます。これは、ヘッダとあるいはその他の"
"メタデータ(我々がオルタネイトを選択するまで、ヘッダはチェックできないことに"
"注意してください)を見ることによってオブジェクトの古さの必要なチェックです。"

#: ../../arch/cache/cache-arch.en.rst:578
msgid "Most of this work is done in::"
msgstr "この処理のほとんどは、以下の中で行われます::"

#: ../../arch/cache/cache-arch.en.rst:582
msgid ""
"First the TTL (time to live) value which can be set in:file:`cache.config` "
"is checked if the request matches the configuration file line. This is done "
"based on when the object was placed in cache, not on any data in the "
"headers."
msgstr ""
"最初に、もしリクエストが設定ファイルの行にマッチしたら、 :file:`cache.config` で"
"設定できる TTL (time to live) の値がチェックされます。これは、ヘッダ内のどのデータ"
"でもなく、オブジェクトがいつキャッシュに置かれたかに基づいて行われます。"

#: ../../arch/cache/cache-arch.en.rst:584
msgid ""
"Next an internal flag (\"needs-revalidate-once\") is checked if the "
":file:`cache.config` value \"revalidate-after\" is not set, and if set the "
"object is marked \"stale\"."
msgstr ""
"次に、 :file:`cache.config` の値 \"revalidate-after\" が設定されておらず、"
"かつオブジェクトが \"stale\" とマークするよう設定されている場合、内部"
"フラグ (\"needs-revalidate-once\") がチェックされます。"

#: ../../arch/cache/cache-arch.en.rst:586
msgid "After these checks the object age is calculated by::"
msgstr "これらのチェックの後、オブジェクトの年齢が、以下により計算されます::"

#: ../../arch/cache/cache-arch.en.rst:590
msgid ""
"and then any configured fuzzing is applied. The limits to this age based on "
"available data is calculated by::"
msgstr ""
"そしてその際、任意の設定されたファジングが適用されます。この年齢の制限は、"
"以下により計算された使用可能なデータに基づきます。::"

#: ../../arch/cache/cache-arch.en.rst:594
msgid ""
"How this age is used is determined by the :file:`records.config` value::"
msgstr ""
"この年齢がどのように使用されるかは、 :file:`records.config` の以下の値により"
"決定されます::"

#: ../../arch/cache/cache-arch.en.rst:598
msgid ""
"If this is zero then the built caclulations are used which compare the "
"freshness limits with document age, modified by any of the client supplied "
"cache control values ``max-age``, ``min-fresh``, ``max-stale`` unless "
"explicitly overridden in :file:`cache.config`."
msgstr ""
"この値がゼロである場合、計算方法は、ドキュメント年齢と共に、新鮮さの限界値を"
"比較する方法が使用され、 :file:`cache.config` で明示的にオーバーライドされて"
"いない値を除き、クライアントが配信した cache control 値、``max-age``, "
"``min-fresh``, ``max-stale`` のどれかを用いて修正されます。"

#: ../../arch/cache/cache-arch.en.rst:600
msgid ""
"If the object is not stale then it is served to the client. If stale the "
"client request may be changed to an ``If Modified Since`` request to "
"revalidate."
msgstr ""
"オブジェクトが古く無い場合、それがクライアントへ配信されます。"
"古い場合、クライアントリクエストは、再検証のため、 ``If Modified Since`` "
"リクエストに変更されるかもしれません。"

#: ../../arch/cache/cache-arch.en.rst:602
msgid ""
"The request is served using a standard virtual connection tunnel "
"(``HttpTunnel``) with the :cpp:class:`CacheVC` acting as the producer and "
"the client ``NetVC`` acting as the sink. If the request is a range request "
"this can be modified with a transform to select the appropriate parts of the"
" object or, if the request contains a single range, it can use the range "
"acceleration."
msgstr ""
"リクエストは、プロデューサとして振る舞う :cpp:class:`CacheVC` と、シンクとして"
"振る舞うクライアント ``NetVC`` 共に、標準的な仮想接続トンネル "
"(``HttpTunnel``) を用いて配信されます。リクエストがレンジリクエストである場合、"
"適切なオブジェクトの部分を選択するための変形を伴って修正出来ます。"
"あるいはリクエストが単一のレンジを含む場合、範囲加速を使用できます。"

#: ../../arch/cache/cache-arch.en.rst:607
msgid ""
"Range acceleration is done by consulting a fragment offset table attached to"
" the earliest ``Doc`` which contains offsets for all fragments past the "
"first. This allows loading the fragment containing the first requested byte "
"immediately rather than performing reads on the intermediate fragments."
msgstr ""
"範囲加速は、過去にファーストだった、全フラグメントへのオフセットを含む、"
"アーリスト ``Doc`` に取り付けられた、フラグメントオフセットテーブルの"
"問い合わせにより行われます。これは、最初にリクエストされたバイトを、"
"中間のフラグメントの読込みが実行されるより早く、フラグメントを読み込む事を"
"許可します。"

#: ../../arch/cache/cache-arch.en.rst:612
msgid "Cache Write"
msgstr "キャッシュライト"

#: ../../arch/cache/cache-arch.en.rst:614
msgid ""
"Writing to cache is handled by an instance of the class "
":cpp:class:`CacheVC`. This is a virtual connection which receives data and "
"writes it to cache, acting as a sink. For a standard transaction data "
"transfers between virtual connections (*VConns*) are handled by "
":cpp:class:HttpTunnel. Writing to cache is done by attaching a ``CacheVC`` "
"instance as a tunnel consumer. It therefore operates in parallel with the "
"virtual connection that transfers data to the client. The data does not flow"
" to the cache and then to the client, it is split and goes both directions "
"in parallel. This avoids any data synchronization issues between the two."
msgstr ""
"キャッシュへの書込みは、 cpp:class:`CacheVC` クラスのインスタンスによって"
"扱われます。おれは、データを受信し、キャッシュにそれを書く、シンクとして"
"振る舞う仮想接続です。標準的なトランザクションのため、 :cpp:class:HttpTunnel に"
"よって扱われる仮想接続 (*VConns*) の間でデータは転送されます。キャッシュへの"
"書き込みは、トンネルコンシューマとして、 ``CacheVC`` インスタンスに取り付け"
"られることにより処理されます。それは従って、クライアントへデータを転送する"
"仮想接続と並列に動作します。データはキャッシュとその後のクライアントへ流れません。"
"それは分離され、並列に両方向に配信されます。これにより、データが2点間で同時に"
"発行することを避けます。"

#: ../../arch/cache/cache-arch.en.rst:0
msgid "Writing to disk"
msgstr "ディスクへの書込み"

#: ../../arch/cache/cache-arch.en.rst:623
msgid ""
"The actual write to disk is handled in a separate thread dedicated to I/O "
"operations, the AIO threads. The cache logic marshals the data and then "
"hands the operation off to the AIO thread which signals back once the "
"operation completes."
msgstr ""
"ディスクへの実際の書込みは、 I/O 命令を発行する別のスレッド、 AIO スレッドに"
"よって扱われます。キャッシュロジックはデータを集約し、その後命令を、 "
"命令完了後すぐに発信し返す AIO スレッドに渡します。"

#: ../../arch/cache/cache-arch.en.rst:627
msgid ""
"While each ``CacheVC`` handles its transactions independently, they do "
"interact at the volume level as each ``CacheVC`` makes calls to the volume "
"object to write its data to the volume content. The ``CacheVC`` accumulates "
"data internally until either the transaction is complete or the amount of "
"data to write exceeds the target fragment size. In the former case the "
"entire object is submitted to the volume to be written. In the latter case a"
" target fragment size amount of data is submitted and the ``CacheVC`` "
"continues to operate on subsequent data. The volume in turn places these "
"write requests in an holding area called the `aggregation buffer`_."
msgstr ""
" ``CacheVC`` が非依存にそのトランザクションをそれぞれ処理する間、それらは"
"ボリュームコンテントへそのデータを書き込む為にボリュームオブジェクトを"
"呼び出す ``CacheVC`` ごとに、ボリュームレベルで対話します。 ``CacheVC`` は"
"トランザクションが完了するか、書き込んだデータの総量が、ターゲットフラグ"
"サイズを超えるまで、内部的なデータを収集します。前者の場合、全体の"
"オブジェクトは書込みのためボリュームに送られます。後者の場合、データの総量の"
"ターゲットフラグメントサイズは送られ、 ``CacheVC`` は続きのデータの書込みのため"
"継続します。この時のボリュームは、 `集約バッファ`_ と呼ばれる、保持している"
"領域にこれらの書込みリクエストを配置します。"

#: ../../arch/cache/cache-arch.en.rst:634
msgid ""
"For objects under the target fragment size there is no consideration of "
"order, the object is simply written to the volume content. For larger "
"objects the earliest ``Doc`` is written first and the first ``Doc`` written "
"last. This provides some detection ability should the object be overwritten."
" Because of the nature of the write cursor no fragment after the first "
"fragment (in the earliest ``Doc``) can be overwritten without also "
"overwriting that first fragment (since we know at the time the object was "
"finalized in the cache the write cursor was at the position of the first "
"``Doc``)."
msgstr ""
"ターゲットフラグメントサイズ以下のオブジェクトのため、順序は考慮しません。"
"オブジェクトは単純にボリュームコンテントに書き込まれます。巨大なオブジェクトの"
"ため、アーリスト ``Doc`` が最初に書き込まれ、ファースト ``Doc`` は最後に"
"書き込まれます。これは、オブジェクトに書き込まれるべき幾つかの検出能力を"
"提供します。書込みカーソルの性質により、最初のフラグメントの上書きも無しに"
"書き込める(アーリスト ``Doc`` の)最初のフラグメントの後にフラグメントはありません。"
"(我々がその時にキャッシュ内でオブジェクトが終了されていたことを知るまで、書込み"
"カーソルはファースト ``Doc`` の位置にいました。)"

#: ../../arch/cache/cache-arch.en.rst:641
msgid ""
"It is the responsibility of the ``CacheVC`` to not submit writes that exceed"
" the target fragment size."
msgstr ""
"ターゲットフラグメントサイズを超えた書込みを発行しないことが、 ``CacheVC`` の"
"役割です。"

#: ../../arch/cache/cache-arch.en.rst:646
msgid "Update"
msgstr "更新"

#: ../../arch/cache/cache-arch.en.rst:648
msgid ""
"Cache write also covers the case where an existing object in the cache is "
"modified. This occurs when"
msgstr "キャッシュライトは、キャッシュ内の存在するオブジェクトを更新する"
"ケースもカバーします。これは以下の時に発生します。"

#: ../../arch/cache/cache-arch.en.rst:650
msgid ""
"A conditional request is made to the origin server and a ``304 - Not "
"Modified`` response is received."
msgstr ""
"条件付きのリクエストはオリジンサーバに作られ、 ``304 - Not Modified`` "
"レスポンスが受信されます。"

#: ../../arch/cache/cache-arch.en.rst:651
msgid ""
"An alternate of the object is retrieved from an origin server and added to "
"the object."
msgstr ""
"オブジェクトのオルタネイトはオリジンサーバから回収され、オブジェクトに追加"
"されます。"

#: ../../arch/cache/cache-arch.en.rst:652
msgid ""
"An alternate of the object is removed (e.g., due to a ``DELETE`` request)."
msgstr ""
"オブジェクトのオルタネイトは、(例えば、 ``DELETE`` リクエストによって)"
"削除されます。"

#: ../../arch/cache/cache-arch.en.rst:654
msgid ""
"In every case the metadata for the object must be modified. Because |TS| "
"never updates data already in the cache this means the first ``Doc`` will be"
" written to the cache again and the volume directory entry updated. Because "
"a client request has already been processed the first ``Doc`` has been read "
"from cache and is in memory. The alternate vector is updated as appropriate "
"(an entry added or removed, or changed to contain the new HTTP headers), and"
" then written to disk. It is possible for multiple alternates to be updated "
"by different ``CacheVC`` instances at the same time. The only contention is "
"the first ``Doc``, the rest of the data for each alternate is completely "
"independent."
msgstr ""
"各ケースにおいて、オブジェクトのメタデータは修正されなくてはいけません。 "
"|TS| は既にキャッシュにあるデータを更新することは無いため、ファースト ``Doc`` "
"は再度キャッシュに書き込まれるでしょう。クライアントリクエストは既に処理されて"
"いるので、ファースト ``Doc`` はキャッシュから読み込まれ、メモリに存在します。"
"オルタネイトベクタは(エントリは新しい HTTP ヘッダを含むように、追加や削除、"
"変更をされるよう)適切に更新され、ディスクに書き込まれます。異なる ``CacheVC`` "
"インスタンスによって、複数のオルタネイトを変更することができます。唯一の競合は"
"ファースト ``Doc`` です。各オルタネイトのデータの残りは完全に独立しています。"

#: ../../arch/cache/cache-arch.en.rst:664
msgid "Aggregation Buffer"
msgstr "集約バッファ"

#: ../../arch/cache/cache-arch.en.rst:666
msgid ""
"Disk writes to cache are handled through an *aggregation buffer*. There is "
"one for each :cpp:class:`Vol` instance. To minimize the number of system "
"calls data is written to disk in units of roughly :ref:`target fragment size"
" <target-fragment-size>` bytes. The algorithm used is simple - data is piled"
" up in the aggregation buffer until no more will fit without going over the "
"targer fragment size, at which point the buffer is written to disk and the "
"volume directory entries for objects with data in the buffer are updated "
"with the actual disk locations for those objects (which are determined by "
"the write to disk action). After the buffer is written it is cleared and "
"process repeats. There is a special lookup table for the aggregation buffer "
"so that object lookup can find cache data in that memory."
msgstr ""
"キャッシュへのディスク書込みは、*集約バッファ* を通して扱われます。 これは、"
"各 :cpp:class:`Vol` インスタンスの一つです。システムコールの回数の最小化の"
"ため、データは粗い :ref:`ターゲットフラグメントサイズ <target-fragment-size>` "
"バイト単位でディスクに書き込まれます。このアルゴリズムは単純に用いられます。 "
"- データは、もうターゲットフラグメントサイズの超過無しに調節できなくなるまで"
"集約バッファに積み上げられます。この点でバッファはディスクに書き込まれ、"
"バッファ内のデータと共に、オブジェクトのボリュームディレクトリエントリが、"
"実際のディスク上のオブジェクトがある場所と更新されます。(ディスクへの書込み"
"動作が決定されます。)バッファが書き込まれた後、クリアされ、処理が繰り返されます。"
"オブジェクトルックアップが、メモリ上のキャッシュデータを見つけられるため、"
"集約バッファの為の特殊なルックアップテーブルがあります。"

#: ../../arch/cache/cache-arch.en.rst:674
msgid ""
"Because data in the aggregation buffer is visible to other parts of the "
"cache, particularly `cache lookup`_, there is no need to push a partial "
"filled aggregation buffer to disk. In effect any such data is effectively "
"memory cached until enough additional cache content arrives to fill the "
"buffer."
msgstr ""
"集約バッファのデータが、キャッシュの他の部分に可視であるため、とりわけ"
" `キャッシュルックアップ`_ では、ディスクへの部分的に満たされた集約"
"バッファをプッシュする必要はありません。この影響で、そのようなデータは"
"バッファを満たすような、十分に追加キャッシュコンテントが届けられるまで、"
"効率的にメモリキャッシュされます。"

#: ../../arch/cache/cache-arch.en.rst:678
msgid ""
"The target fragment size has little effect on small objects because the "
"fragment sized is used only to parcel out disk write operations. For larger "
"objects the effect very significant as it causes those objects to be broken "
"up in to fragments at different locations on in the volume. Each fragment "
"write has its own entry in the volume directory which are computational "
"chained (each cache key is computed from the previous one). If possible a "
"fragment table is accumulated in the earliest ``Doc`` which has the offsets "
"of the first byte for each fragment."
msgstr ""
"サイズに切られたフラグメントは、書き込み命令をディスクに分配するためだけに"
"使用されるため、ターゲットフラグメントサイズは、小サイズのオブジェクトに"
"少々の影響があります。巨大なオブジェクトでは、オブジェクトがディスク内の"
"別の場所のフラグメントに分割されることになるので、この影響は非常に重要です。"
"各フラグメント書込みは、計算的に繋げられるボリュームエントリの、それら自身の"
"エントリを持ちます。(各キャッシュキーは、過去のものから計算されます)もし可能なら、"
"フラグメントテーブルは、各フラグメントへの最初のバイトのオフセットを持つ"
"アーリスト ``Doc`` に蓄積されます。"

#: ../../arch/cache/cache-arch.en.rst:685
msgid "Evacuation Mechanics"
msgstr "退避のメカニズム"

#: ../../arch/cache/cache-arch.en.rst:687
msgid ""
"By default the write cursor will overwrite (de facto evict from cache) "
"objects as it proceeds once it has gone around the cache stripe at least "
"once. In some cases this is not acceptable and the object is *evacuated* by "
"reading it from the cache and then writing it back to cache which moves the "
"physical storage of the object from in front of the write cursor to behind "
"the write cursor. Objects that are evacuated are handled in this way based "
"on data in stripe data structures (attached to the :cpp:class:`Vol` "
"instance)."
msgstr ""
"デフォルトでは、一度キャッシュを一周するまで進むと、少なくとも一度は、書込み"
"カーソルはオブジェクトを上書き(事実上のキャッシュからの追い出し)します。"
"幾つかのケースでは、これは受け入れられず、オブジェクトはキャッシュからの"
"読込みと、オブジェクトの物理ストレージを、書込みカーソルの手前から背後に"
"移動させたキャッシュへの書き戻しによる *退避* が行われます。退避された"
"オブジェクトは、ストライプデータ構造( :cpp:class:`Vol` インスタンスが"
"保持する)のデータに基づくこの方法で扱われます。"

#: ../../arch/cache/cache-arch.en.rst:693
msgid ""
"Evacuation data structures are defined by dividing up the volume content in "
"to a disjoint and contiguous set of regions of ``EVACUATION_BUCKET_SIZE`` "
"bytes. The :cpp:member:`Vol::evacuate` member is an array with an element "
"for each evacuation region. Each element is a doubly linked list of "
":cpp:class:`EvacuationBlock` instances. Each instance contains a "
":cpp:class:`Dir` that specifies the fragment to evacuate. It is assumed that"
" an evacuation block is placed in the evacuation bucket (array element) that"
" corresponds to the evacuation region in which the fragment is located "
"although no ordering per bucket is enforced in the linked list (this sorting"
" is handled during evacuation). Objects are evacuated by specifying the "
"first or earliest fragment in the evactuation block. The evactuation "
"operation will then continue the evacuation for subsequent fragments in the "
"object by adding those fragments in evacuation blocks. Note that the actual "
"evacuation of those fragments is delayed until the write cursor reaches the "
"fragments, it is not ncessarily done at the time the first / earliest "
"fragment is evacuated."
msgstr ""
"退避データ構造は、分離され、 ``EVACUATION_BUCKET_SIZE`` バイトの連続した領域の"
"セットの上のボリュームコンテントに分割されて定義されます。"
" :cpp:member:`Vol::evacuate` のメンバは、各退避領域の要素を持つ配列です。"
"各要素は、 :cpp:class:`EvacuationBlock` インスタンスの双方向連結リストです。"
"各インスタンスは、退避するフラグメントを指定する :cpp:class:`Dir` を含みます。"
"退避ブロックは、各バケットは連結リスト内で強制的に整列されないにも関わらず、"
"(このソートは退避中に扱われます。)フラグメントが配置された退避領域に合致する、"
"退避バケット(配列の要素)に配置されるものと仮定します。オブジェクトは、退避ブロックの"
"ファーストもしくはアーリストフラグメントを指定する事で退避されます。退避命令は、"
"後に続くフラグメントの退避を、退避ブロックのそれらのフラグメントを追加することに"
"することによって継続するでしょう。それらのフラグメントの実際の退避は、書込み"
"カーソルがフラグメントに到達するまで遅延されることに注意してください。 これは"
"ファースト / アーリストフラグメントが退避される時は、必然的に行われません。"

#: ../../arch/cache/cache-arch.en.rst:704
msgid ""
"There are two types of evacuations, reader based and forced. The "
"``EvacuationBlock`` has a reader count to track this. If the reader count is"
" zero, then it is a forced evacuation and the the target, if it exists, will"
" be evacuated when the write cursor gets close. If the reader value is non-"
"zero then it is a count of entities that are currently expecting to be able "
"to read the object. Readers increment the count when they require read "
"access to the object, or create the ``EvacuationBlock`` with a count of 1. "
"When a reader is finished with the object it decrements the count and "
"removes the ``EvacuationBlock`` if the count goes to zero. If the "
"``EvacuationBlock`` already exists with a count of zero, the count is not "
"modified and the number of readers is not tracked, so the evacuation is "
"valid as long as the object exists."
msgstr ""
"退避には二つのタイプがあります。読み込みベースと強制です。 "
"``EvacuationBlock`` は、これを追跡する為に読込みカウントを持ちます。"
"読み込みカウントがゼロの場合、退避が強制され、ターゲットが存在しない場合は、"
"書き込みカーソルが接近した時に退避されるでしょう。読み込み値が非ゼロである"
"場合は、それは現在はオブジェクトを読み込める予測の実体の数です。オブジェクトを"
"横断した読込みが要求される、もしくは ``EvacuationBlock`` を1カウントで生成する"
"時、読み込みはカウントを増加します。リーダーがオブジェクトの読込みを終了する際、"
"カウントは減少し、カウントがゼロになった場合 ``EvacuationBlock`` は除去され"
"ます。 ``EvacuationBlock`` が、カウンタがゼロになった状態で、既に存在する場合、"
"カウントは修正されず、リーダーの数は追跡されなくなり、それによりオブジェクトが"
"存在する限り、退避は正常です。"

#: ../../arch/cache/cache-arch.en.rst:712
msgid ""
"Evacuation is driven by cache writes, essentially in "
":cpp:member:`Vol::aggWrite`. This method processes the pending cache virtual"
" connections that are trying to write to the stripe. Some of these may be "
"evacuation virtual connections. If so then the completion callback for that "
"virtual connection is called as the data is put in to the aggregation "
"buffer."
msgstr ""
"退避は、基本的には :cpp:member:`Vol::aggWrite` 内で、キャッシュライトにより"
"動作します。このメソッドは、ストライプに書込みを試みた、保留している"
"しているキャッシュ仮想接続を処理します。これらのうち幾つかは退避仮想接続"
"でしょう。そうである場合、仮想接続の完了時のコールバックは、集約バッファに"
"置かれたデータとして呼び出されます。"

#: ../../arch/cache/cache-arch.en.rst:717
msgid ""
"When no more cache virtual connections can be processed (due to an empty "
"queue or the aggregation buffer filling) then :cpp:member:`Vol::evac_range` "
"is called to clear the range to be overwritten plus an additional "
":ts:const:`EVACUATION_SIZE` range. The buckets covering that range are "
"checked. If there are any items in the buckets a new cache virtual "
"connection (a \"doc evacuator\") is created and used to read the evacuation "
"item closest to the write cursor (i.e. with the smallest offset in the "
"stripe) instead of the aggregation write proceeding. When the read completes"
" it is checked for validity and if valid, the cache virtual connection for "
"it is placed at the front of the write queue for the stripe and the write "
"aggregation resumed."
msgstr ""
"処理できるキャッシュ仮想接続が無くなった際、追加の ts:const:`EVACUATION_SIZE` "
"範囲と合わせ、範囲をクリアするために、 :cpp:member:`Vol::evac_range` が"
"呼び出されます。その範囲をカバーするバケットはチェックされます。バケットに"
"要素がある場合、新しいキャッシュ仮想接続 (a \"doc evacuator\") が生成され、"
"集約書込みを進める代わりに、(例えば、ストライプの最小のオフセットと共に)"
"書込みカーソルを閉じた退避要素を読み込む為に使用されます。読み込みが完了した際、"
"検証のためチェックされ、正常であればそれのキャッシュ仮想接続は、ストライプの"
"書き込みキューの前方に配置され、書込み集約はレジュームされます。"

#: ../../arch/cache/cache-arch.en.rst:725
msgid ""
"Before doing a write, the method :cpp:func:`Vol::evac_range()` is called to "
"start an evacuation. If any fragments are found in the buckets in the range "
"the earliest such fragment (smallest offset, closest to the write cursor) is"
" selected and read from disk and the aggregation buffer write is suspended. "
"The read is done via a cache virtual connection which also effectively "
"serves as the read buffer. Once the read is complete, that cache virtual "
"connection instance (the \"doc evacuator\") is place at the front of the "
"stripe write queue and written out in turn. Because the fragment data is now"
" in memory it is acceptable to overwrite the disk image."
msgstr ""
"書き込みを行う前に、退避を開始するために、 :cpp:func:`Vol::evac_range()` "
"メソッドが呼び出されます。フラグメントが範囲内のバケット内に見つかった場合、"
"(最小オフセット、書込みカーソルを閉ざした)アーリストフラグメントが選択され、"
"ディスクから読み込まれ、集約バッファの書込みが延期されます。読み込みは、"
"読み込みバッファとして効率的な配信もする、キャッシュ仮想接続を介して行われ"
"ます。一旦読み込みが完了したら、キャッシュ仮想接続インスタンス (the \"doc "
"evacuator\") は、ストライプ書込みキューの前方に配置され、書き出されます。"
"フラグメントデータはその時メモリにあるため、ディスクイメージの書込みは"
"受理できます。"

#: ../../arch/cache/cache-arch.en.rst:732
msgid ""
"Note that when normal stripe writing is resumed, this same check is done "
"again, each time evauating (if needed) a fragment and queuing them for "
"writing in turn."
msgstr ""
"通常のストライプの書込みがレジュームした際、これと同じチェックが再度行われ、"
"各タイミングで(必要であれば)フラグメントを退避し、その時書込み用にキューに"
"格納されることに注意してください。"

#: ../../arch/cache/cache-arch.en.rst:735
msgid ""
"Updates to the directory are done when the write for the evacuated fragment "
"completes. Multi-fragment objects are detected after the read completes for "
"a fragment. If it is not the first fragment then the next fragment is marked"
" for evacuation (which in turn, when it is read, will pull the subsequent "
"fragment). The logic doesn't seem to check the length and presumes that the "
"end of the alternate is when the next key is not in the directory."
msgstr ""
"ディレクトリの更新は、退避されたフラグメントの書込みが完了した時に行われます。"
"複数フラグメントオブジェクトは、フラグメントの読み込みが完了した後に検出され"
"ます。ファーストフラグメントが無い場合、次のフラグメントが退避のためにマーク"
"されます。(この時、読込みであった際、その続きのフラグメントが読み出される"
"でしょう) このロジックは、長さをチェックし、次のキーがディレクトリに無い時の"
"オルタネイトの終わりを推定するように見えません。"

#: ../../arch/cache/cache-arch.en.rst:740
msgid ""
"This interacts with the \"one at a time\" strategy of the aggregation write "
"logic. If a fragment is close to the fragment being evacuated it may end up "
"in the same evacuation bucket. Because the aggregation write checks every "
"time for the \"next\" fragment to evacuate it will find that next fragment "
"and evacuate it before it is overwritten."
msgstr ""
"これは、集約書込みロジックの \"一つずつ\" のストラテジで対応します。"
"フラグメントが、退避されているフラグメントに閉じられている場合、最終的に"
"同じ退避バケット内に置かれるでしょう。集約書込みは、退避のために \"次の\" "
"フラグメントのために毎回チェックするので、次のフラグメントを検索し、それを"
"上書きされる前までに退避するでしょう。"

#: ../../arch/cache/cache-arch.en.rst:757
msgid "Evacuation Operation"
msgstr "退避命令"

#: ../../arch/cache/cache-arch.en.rst:759
msgid ""
"The primary source of fragments to be evacuated are active fragments. That "
"is fragments which are currently open, to be read or written. This is "
"tracked by the reader value in the evacuation blocks noted above."
msgstr ""
"退避が行われているフラグメントの主要なソースは、アクティブなフラグメントです。"
"これは現在開かれており、読込みまたは書込みがされているフラグメントです。これは"
"上で注意した、退避ブロックのリーダー値によって追跡されます。"

#: ../../arch/cache/cache-arch.en.rst:761
msgid ""
"If object pinning is enabled then a scan is done on a regular basis as the "
"write cursor moves to detected pinned objects and mark them for evacuation."
msgstr ""
"オブジェクトのピン留めが有効な場合、書き込みカーソルが検出された、ピン留め"
"されたオブジェクトまで動作し、退避のためのマークを行う為に定期的にスキャンが"
"行われます。"

#: ../../arch/cache/cache-arch.en.rst:763
msgid ""
"Fragments can also be evacuated through *hit evacuation*. This is configured"
" by :ts:cv:`proxy.config.cache.hit_evacuate_percent` and "
":ts:cv:`proxy.config.cache.hit_evacuate_size_limit`. When a fragment is read"
" it is checked to see if it is close and in front of the write cursor, close"
" being less than the specified percent of the size of the stripe. If set at "
"the default value of 10, then if the fragment is withing 10% of the size of "
"the stripe it is marked for evacuation. This is cleared if the write cursor "
"passes through the fragment while it remains open (as all open objects are "
"evacuated). If when the object is closed the fragment is still marked then "
"it is placed in the appropriate evacuation bucket."
msgstr ""
"フラグメントは、 *ヒットした退避* を跨いだ退避も可能です。これは、 "
":ts:cv:`proxy.config.cache.hit_evacuate_percent` と、"
":ts:cv:`proxy.config.cache.hit_evacuate_size_limit` によって設定されます。 "
"フラグメントが読み込まれた際、閉じられて、書込みカーソルの前方にいるかを確認"
"する為にチェックされます。ストライプのサイズの指定されたパーセント以下のものを"
"閉じます。デフォルト値の 10 が設定されている場合、フラグメントがストライプの"
"サイズの 10% 書き込まれている場合に、退避の為のマークが付けられます。書込み"
"カーソルが、開かれているまま残されているフラグメントを通過する場合、これが"
"明確にされます。(全ての開かれたオブジェクトは退避されます。)オブジェクトが"
"閉じられた際、フラグメントがマークされていた場合、適切な退避バケットに配置"
"されます。"

#: ../../arch/cache/cache-arch.en.rst:766
msgid "Initialization"
msgstr "初期化"

#: ../../arch/cache/cache-arch.en.rst:768
msgid ""
"Initialization starts with an instance of :cpp:class:`Store` reading the "
"storage configuration file, by default :file:`storage.config`. For each "
"valid element in the file an instance of :cpp:class:`Span` is created. These"
" are of basically four types,"
msgstr ""
"初期化処理は、ストレージ設定ファイル、デフォルトでは :file:`storage.config` を"
"読み込む :cpp:class:`Store` インスタンスと共に開始します。ファイルの有効な要素の"
"それぞれについて、 :cpp:class:`Span` インスタンスが生成されます。これらは基本的に "
"4 つのタイプがあります。"

#: ../../arch/cache/cache-arch.en.rst:772
msgid "File"
msgstr "ファイル"

#: ../../arch/cache/cache-arch.en.rst:773
msgid "Directory"
msgstr "ディレクトリ"

#: ../../arch/cache/cache-arch.en.rst:774
msgid "Disk"
msgstr "ディスク"

#: ../../arch/cache/cache-arch.en.rst:775
msgid "Raw device"
msgstr "ローデバイス"

#: ../../arch/cache/cache-arch.en.rst:777
msgid ""
"After setting all the `Span` instances they are grouped by device id to "
"internal linked lists attached to the :cpp:member:`Store::disk` array [#]_. "
"Spans that refer to the same directory, disk, or raw device are coalesced in"
" to a single span. Spans that refer to the same file with overlapping "
"offsets are also coalesced [#]_. This is all done in "
":c:func:`ink_cache_init()` called during startup."
msgstr ""
"全ての `Span` インスタンスが設定された後、それらはデバイスIDによって、 "
":cpp:member:`Store::disk` の配列に繋げられた、内部的な連結リストにグループ化"
"されます。同一のディレクトリ、ディスクやローデバイスをを参照するスパンは、"
"単一のスパンに結合されます。同じオフセットを持つ同一のファイルを参照する"
"スパンも、結合されます。この処理は全て、起動時に :c:func:`ink_cache_init()` で"
"処理されます。"

#: ../../arch/cache/cache-arch.en.rst:781
msgid ""
"After configuration initialization the cache processor is started by calling"
" :ccp:func:`CacheProcessor::start()`. This does a number of things."
msgstr ""
"設定の初期化の後、 :ccp:func:`CacheProcessor::start()` の呼び出しにより、"
"キャッシュプロセッサが開始されます。これは様々な処理を行います"

#: ../../arch/cache/cache-arch.en.rst:784
msgid ""
"For each valid span, an instance of :cpp:class:`CacheDisk` is created. This "
"class is a continuation and so can be used to perform potentially blocking "
"operations on the span. This what is passed to the AIO threads to be called "
"when an I/O operation completes. These are then dispatched to AIO threads to"
" perform storage unit initialization. After all of those have completed, the"
" resulting storage is distributed across the volumes in "
":c:func:`cplist_reconfigure`. The :cpp:class:`CacheVol` instances are "
"created at this time."
msgstr ""
"各有効なスパンで、 :cpp:class:`CacheDisk` のインスタンスが生成されます。"
"このクラスは、継続であり、スパンにおいてブロッキング命令を処理するのに"
"用いることが可能です。これは I/O 命令が完了した時に呼び出されるように、 AIO "
"スレッドに渡されます。これらはその際、ストレージユニットの初期化を行うために、"
" AIO スレッドにディスパッチされます。これら全てが完了した後、ストレージは "
":c:func:`cplist_reconfigure` でボリュームを横断して分配されます。"

#: ../../arch/cache/cache-arch.en.rst:790
msgid "Footnotes"
msgstr "脚注"

#: ../../arch/cache/cache-arch.en.rst:791
msgid ""
"`Work is under way <https://issues.apache.org/jira/browse/TS-2020>`_ on "
"extending this to include objects that are in the ram cache."
msgstr ""
"ram キャッシュのオブジェクトを含めるため、これを拡張する "
"<https://issues.apache.org/jira/browse/TS-2020>`_ の作業が進められています。"

#: ../../arch/cache/cache-arch.en.rst:794
msgid ""
"This linked list is mostly ignored in later processing, causing all but one "
"file or directory storage units on the same device to be ignored. See "
"`TS-1869 <https://issues.apache.org/jira/browse/TS-1869>`_."
msgstr ""
"この連結リストは、後の処理ではほとんど無視されます。1 つを除き全ての、同一"
"デバイスのストレージユニットのファイルやディレクトリが無視されることに起因します。 "
"`TS-1869 <https://issues.apache.org/jira/browse/TS-1869>`_ を見てください。"

#: ../../arch/cache/cache-arch.en.rst:797
msgid ""
"It is unclear to me how that can happen, as the offsets are computed later "
"and should all be zero at the time the spans are coalesced, and as far as I "
"can tell the sort / coalesce is only done during initialization."
msgstr ""
"オフセットが後で計算され、その時結合されたスパンが全てゼロになるべきで、"
"私が初期化中にのみ行われるソート / 結合処理について教えられる限りでは、"
"どんなことが起こせるか、私には定かではありません。"

#: ../../arch/cache/cache-arch.en.rst:95
msgid "cache directory"
msgstr "キャッシュディレクトリ"

#: ../../arch/cache/cache-arch.en.rst:101
msgid "directory entry"
msgstr "ディレクトリエントリ"

#: ../../arch/cache/cache-arch.en.rst:102
msgid "fragment"
msgstr "フラグメント"

#: ../../arch/cache/cache-arch.en.rst:103
msgid "cache ID"
msgstr "キャッシュ ID"

#: ../../arch/cache/cache-arch.en.rst:243
msgid "alternate"
msgstr "オルタネイト"

#: ../../arch/cache/cache-arch.en.rst:442
msgid "DIR_DEPTH"
msgstr "DIR_DEPTH"

#: ../../arch/cache/cache-arch.en.rst:442
msgid "index segment"
msgstr "インデックスセグメント"

#: ../../arch/cache/cache-arch.en.rst:442
msgid "index buckets"
msgstr "インデックスバケット"
